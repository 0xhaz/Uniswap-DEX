{
  "language": "Solidity",
  "sources": {
    "contracts/core/SwapPairTokens.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\nimport \"../libraries/Math.sol\";\nimport \"../libraries/UQ112x112.sol\";\nimport \"../interfaces/IERC20.sol\";\nimport \"../interfaces/ISwapFactory.sol\";\nimport \"./SwapTokens.sol\";\n\ncontract SwapPairTokens is SwapTokens {\n    using SafeMath for uint256;\n    using UQ112x112 for uint224;\n\n    uint256 public constant MINIMUM_LIQUIDITY = 10 ** 3;\n    bytes4 private constant SELECTOR =\n        bytes4(keccak256(bytes(\"transfer(address,uint256)\")));\n\n    address public factory;\n    address public token0;\n    address public token1;\n\n    uint112 private reserve0; // uses single storage slot, accessible via getReserves\n    uint112 private reserve1; // uses single storage slot, accessible via getReserves\n    uint32 private blockTimestampLast; // uses single storage slot, accessible via getReserves\n\n    uint256 public price0CumulativeLast;\n    uint256 public price1CumulativeLast;\n    uint256 public kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity event\n\n    uint256 private unlocked = 1;\n\n    modifier lock() {\n        require(unlocked == 1, \"SwapPairTokens: LOCKED\");\n        unlocked = 0;\n        _;\n        unlocked = 1;\n    }\n\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n    event Burn(\n        address indexed sender,\n        uint256 amount0,\n        uint256 amount1,\n        address indexed to\n    );\n    event Swap(\n        address indexed sender,\n        uint256 amount0In,\n        uint256 amount1In,\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address indexed to\n    );\n    event Sync(uint256 reserve0, uint256 reserve1);\n\n    constructor() {\n        factory = msg.sender;\n    }\n\n    function getReserves()\n        public\n        view\n        returns (\n            uint112 _reserve0,\n            uint112 _reserve1,\n            uint32 _blockTimestampLast\n        )\n    {\n        _reserve0 = reserve0;\n        _reserve1 = reserve1;\n        _blockTimestampLast = blockTimestampLast;\n    }\n\n    // called once by the factory at time of deployment\n    function initialize(address _token0, address _token1) external {\n        require(msg.sender == factory, \"SwapPairTokens: FORBIDDEN\"); // sufficient check\n        token0 = _token0;\n        token1 = _token1;\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function burn(\n        address _to\n    ) external lock returns (uint256 _amount0, uint256 _amount1) {\n        (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\n        address _token0 = token0; // gas savings\n        address _token1 = token1; // gas savings\n        uint256 balance0 = IERC20(_token0).balanceOf(address(this));\n        uint256 balance1 = IERC20(_token1).balanceOf(address(this));\n        uint256 liquidity = balanceOf[address(this)];\n\n        bool feeOn = _collectFee(_reserve0, _reserve1);\n        uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\n        _amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution\n        _amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution\n        require(\n            _amount0 > 0 && _amount1 > 0,\n            \"SwapPairTokens: INSUFFICIENT_LIQUIDITY_BURNED\"\n        );\n        _burn(address(this), liquidity);\n        _safeTransfer(_token0, _to, _amount0);\n        _safeTransfer(_token1, _to, _amount1);\n        balance0 = IERC20(_token0).balanceOf(address(this));\n        balance1 = IERC20(_token1).balanceOf(address(this));\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        if (feeOn) kLast = uint256(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date\n        emit Burn(msg.sender, _amount0, _amount1, _to);\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function mint(address _to) external lock returns (uint256 liquidity) {\n        (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\n        uint256 balance0 = IERC20(token0).balanceOf(address(this));\n        uint256 balance1 = IERC20(token1).balanceOf(address(this));\n        uint256 amount0 = balance0.sub(_reserve0);\n        uint256 amount1 = balance1.sub(_reserve1);\n\n        bool feeOn = _collectFee(_reserve0, _reserve1);\n        uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\n        if (_totalSupply == 0) {\n            liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);\n            _mint(address(0), MINIMUM_LIQUIDITY);\n            // permanently lock the first MINIMUM_LIQUIDITY tokens\n        } else {\n            liquidity = Math.min(\n                balance0.mul(_totalSupply) / _reserve0,\n                balance1.mul(_totalSupply) / _reserve1\n            );\n        }\n        require(liquidity > 0, \"SwapPairTokens: INSUFFICIENT_LIQUIDITY_MINTED\");\n        _mint(_to, liquidity);\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        if (feeOn) kLast = uint256(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date\n        emit Mint(msg.sender, amount0, amount1);\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function swap(\n        uint256 _amount0Out,\n        uint256 _amount1Out,\n        address _to,\n        bytes calldata _data\n    ) external lock {\n        require(\n            _amount0Out > 0 || _amount1Out > 0,\n            \"SwapPairTokens: INSUFFICIENT_OUTPUT_AMOUNT\"\n        );\n        (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\n        require(\n            _amount0Out < _reserve0 && _amount1Out < _reserve1,\n            \"SwapPairTokens: INSUFFICIENT_LIQUIDITY\"\n        );\n\n        uint256 balance0;\n        uint256 balance1;\n        {\n            // scope for _token{0,1}, avoids stack too deep errors\n            address _token0 = token0;\n            address _token1 = token1;\n            require(\n                _to != _token0 && _to != _token1,\n                \"SwapPairTokens: INVALID_TO\"\n            );\n            if (_amount0Out > 0) _safeTransfer(_token0, _to, _amount0Out); // optimistically transfer tokens\n            if (_amount1Out > 0) _safeTransfer(_token1, _to, _amount1Out); // optimistically transfer tokens\n            balance0 = IERC20(_token0).balanceOf(address(this));\n            balance1 = IERC20(_token1).balanceOf(address(this));\n        }\n        uint256 amount0In = balance0 > _reserve0 - _amount0Out\n            ? balance0 - (_reserve0 - _amount0Out)\n            : 0;\n        uint256 amount1In = balance1 > _reserve1 - _amount1Out\n            ? balance1 - (_reserve1 - _amount1Out)\n            : 0;\n        require(\n            amount0In > 0 || amount1In > 0,\n            \"SwapPairTokens: INSUFFICIENT_INPUT_AMOUNT\"\n        );\n        {\n            // scope for reserve{0,1}Adjusted, avoids stack too deep errors\n            uint256 balance0Adjusted = (\n                balance0.mul(1000).sub(amount0In.mul(3))\n            );\n            uint256 balance1Adjusted = (\n                balance1.mul(1000).sub(amount1In.mul(3))\n            );\n            require(\n                balance0Adjusted.mul(balance1Adjusted) >=\n                    uint256(_reserve0).mul(_reserve1).mul(1000 ** 2),\n                \"SwapPairTokens: K\"\n            );\n        }\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n\n        emit Swap(\n            msg.sender,\n            amount0In,\n            amount1In,\n            _amount0Out,\n            _amount1Out,\n            _to\n        );\n    }\n\n    // force balances to match reserves\n    function skim(address _to) external lock {\n        address _token0 = token0; // gas savings\n        address _token1 = token1; // gas savings\n        _safeTransfer(\n            _token0,\n            _to,\n            IERC20(_token0).balanceOf(address(this)).sub(reserve0)\n        );\n        _safeTransfer(\n            _token1,\n            _to,\n            IERC20(_token1).balanceOf(address(this)).sub(reserve1)\n        );\n    }\n\n    // force reserves to match balances\n    function sync() external lock {\n        _update(\n            IERC20(token0).balanceOf(address(this)),\n            IERC20(token1).balanceOf(address(this)),\n            reserve0,\n            reserve1\n        );\n    }\n\n    // update reserves and, on the first call per block, price accumulators\n    function _update(\n        uint256 balance0,\n        uint256 balance1,\n        uint112 _reserve0,\n        uint112 _reserve1\n    ) private {\n        require(\n            balance0 <= (2 ** 122 - 1) && balance1 <= (2 ** 122 - 1),\n            \"SwapPairTokens: OVERFLOW\"\n        );\n        uint32 blockTimestamp = uint32(block.timestamp % 2 ** 32);\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\n        if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {\n            // * never overflows, and + overflow is desired\n            price0CumulativeLast +=\n                uint256(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) *\n                timeElapsed;\n            price1CumulativeLast +=\n                uint256(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) *\n                timeElapsed;\n        }\n        reserve0 = uint112(balance0);\n        reserve1 = uint112(balance1);\n        blockTimestampLast = blockTimestamp;\n        emit Sync(reserve0, reserve1);\n    }\n\n    // if fee is on, mint liquidity equivalent to 1/6th of the growth in sqrt(k)\n    function _collectFee(\n        uint112 _reserve0,\n        uint112 _reserve1\n    ) private returns (bool feeOn) {\n        address feeTo = ISwapFactory(factory).feeTo();\n        feeOn = feeTo != address(0);\n        uint256 _kLast = kLast; // gas savings\n        if (feeOn) {\n            if (_kLast != 0) {\n                uint256 rootK = Math.sqrt(uint256(_reserve0).mul(_reserve1));\n                uint256 rootKLast = Math.sqrt(_kLast);\n                if (rootK > rootKLast) {\n                    uint256 numerator = totalSupply.mul(rootK.sub(rootKLast));\n                    uint256 denominator = rootK.mul(5).add(rootKLast);\n                    uint256 liquidity = numerator / denominator;\n                    if (liquidity > 0) _mint(feeTo, liquidity);\n                }\n            }\n        } else if (_kLast != 0) {\n            kLast = 0;\n        }\n    }\n\n    function _safeTransfer(\n        address _token,\n        address _to,\n        uint256 _value\n    ) private {\n        (bool success, bytes memory data) = _token.call(\n            abi.encodeWithSelector(SELECTOR, _to, _value)\n        );\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"SwapPairTokens: TRANSFER_FAILED\"\n        );\n    }\n}\n"
    },
    "contracts/core/SwapPairTokens2.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\nimport \"./SwapTokens.sol\";\nimport \"../interfaces/IERC20.sol\";\n\ncontract SwapPairTokens2 is SwapTokens {\n    IERC20 public immutable token0;\n    IERC20 public immutable token1;\n\n    // tracks the internal balances of the pool\n    uint256 public reserve0;\n    uint256 public reserve1;\n\n    uint256 public price0CumulativeLast;\n    uint256 public price1CumulativeLast;\n    uint256 public kLast;\n\n    constructor(address _token0, address _token1) {\n        token0 = IERC20(_token0);\n        token1 = IERC20(_token1);\n    }\n\n    // swap tokens\n    function swap(\n        address _tokenIn,\n        uint256 _amountIn\n    ) external returns (uint256 amountOut) {\n        require(\n            _tokenIn == address(token0) || _tokenIn == address(token1),\n            \"INVALID TOKEN\"\n        );\n        require(_amountIn > 0, \"INSUFFICIENT INPUT AMOUNT\");\n\n        bool isToken0 = _tokenIn == address(token0);\n\n        // assigning the tokens to the correct variables\n        (\n            IERC20 tokenIn,\n            IERC20 tokenOut,\n            uint256 reserveIn,\n            uint256 reserveOut\n        ) = isToken0\n                ? (token0, token1, reserve0, reserve1)\n                : (token1, token0, reserve1, reserve0);\n\n        // transferring the tokens from the sender to the contract\n        tokenIn.transferFrom(msg.sender, address(this), _amountIn);\n\n        // fee calculation of 0.3%\n        uint256 _amountInWithFee = (_amountIn * 997) / 1000;\n\n        /**\n         * ydx / (x + dx) = dy\n         * y = reserveOut, dy = _amountOut\n         * x = reserveIn, dx = _amountInWithFee\n         */\n        amountOut =\n            (reserveOut * _amountInWithFee) /\n            (reserveIn + _amountInWithFee);\n\n        // tokenOut transfer to the sender\n        tokenOut.transfer(msg.sender, amountOut);\n\n        // updating the reserves\n        _update(\n            token0.balanceOf(address(this)),\n            token1.balanceOf(address(this))\n        );\n    }\n\n    function addLiquidity(\n        uint256 _amount0,\n        uint256 _amount1\n    ) external returns (uint256 shares) {\n        token0.transferFrom(msg.sender, address(this), _amount0);\n        token1.transferFrom(msg.sender, address(this), _amount1);\n\n        if (reserve0 > 0 || reserve1 > 0) {\n            require(\n                reserve0 * _amount1 == reserve1 * _amount0,\n                \"x / y != dx / dy\"\n            );\n        }\n\n        if (totalSupply == 0) {\n            shares = _sqrt(_amount0 * _amount1);\n        } else {\n            // whichever value is the minimum will be the shares of (dx * T / x) or (dy * T / y\n            shares = _min(\n                (_amount0 * totalSupply) / reserve0,\n                (_amount1 * totalSupply) / reserve1\n            );\n        }\n    }\n\n    function removeLiquidity(\n        uint256 _shares\n    ) external returns (uint256 amount0, uint256 amount1) {\n        uint256 bal0 = token0.balanceOf(address(this));\n        uint256 bal1 = token1.balanceOf(address(this));\n\n        // calculating the amount of tokens to be transferred\n        amount0 = (bal0 * _shares) / totalSupply;\n        amount1 = (bal1 * _shares) / totalSupply;\n        require(amount0 > 0 && amount1 > 0, \"INSUFFICIENT LIQUIDITY\");\n\n        // burning the shares and updating the reserves\n        _burn(msg.sender, _shares);\n        _update(bal0 - amount0, bal1 - amount1);\n\n        // transferring the tokens to the sender\n        token0.transfer(msg.sender, amount0);\n        token1.transfer(msg.sender, amount1);\n    }\n\n    // to update the reserver of the pool\n    function _update(uint256 _reserve0, uint256 _reserve1) private {\n        require(\n            _reserve0 <= type(uint112).max && _reserve1 <= type(uint112).max,\n            \"OVERFLOW\"\n        );\n        reserve0 = _reserve0;\n        reserve1 = _reserve1;\n    }\n\n    // to calculate the square root of the number\n    function _sqrt(uint256 y) private pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n\n    // to find the minimum of the two numbers\n    function _min(uint256 x, uint256 y) private pure returns (uint256) {\n        return x = x <= y ? x : y;\n    }\n}\n"
    },
    "contracts/core/SwapTokens.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\nimport \"../libraries/safeMath.sol\";\n\ncontract SwapTokens {\n    using SafeMath for uint256;\n\n    string public constant name = \"SwapTokens\";\n    string public constant symbol = \"SWT\";\n    uint8 public constant decimals = 18;\n\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    mapping(address => uint256) public nonces;\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function approve(address _spender, uint256 _value) external returns (bool) {\n        _approve(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function transfer(address _to, uint256 _value) external returns (bool) {\n        _transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 value\n    ) external returns (bool) {\n        if (allowance[_from][msg.sender] != 2 ** 112 - 1) {\n            allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(\n                value\n            );\n        }\n\n        _transfer(_from, _to, value);\n        return true;\n    }\n\n    function _transfer(address _from, address _to, uint256 value) private {\n        balanceOf[_from] = balanceOf[_from].sub(value);\n        balanceOf[_to] = balanceOf[_to].add(value);\n        emit Transfer(_from, _to, value);\n    }\n\n    function _approve(\n        address _owner,\n        address _spender,\n        uint256 _value\n    ) private {\n        require(_spender != address(0), \"Spender cannot be 0 address\");\n        require(_owner != address(0), \"Owner cannot be 0 address\");\n\n        allowance[_owner][_spender] = _value;\n        emit Approval(_owner, _spender, _value);\n    }\n\n    function _mint(address _to, uint256 _value) internal {\n        totalSupply = totalSupply.add(_value);\n        balanceOf[_to] = balanceOf[_to].add(_value);\n        emit Transfer(address(0), _to, _value);\n    }\n\n    function _burn(address _from, uint256 _value) internal {\n        balanceOf[_from] = balanceOf[_from].sub(_value);\n        totalSupply = totalSupply.sub(_value);\n        emit Transfer(_from, address(0), _value);\n    }\n}\n"
    },
    "contracts/factory/SwapPairTokensFactory.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\nimport \"../core/SwapPairTokens.sol\";\n\ncontract SwapPairTokensFactory {\n    address public feeTo;\n    address public feeToSetter;\n\n    mapping(address => mapping(address => address)) public getPair;\n    address[] public allPairs;\n\n    event PairCreated(\n        address indexed token0,\n        address indexed token1,\n        address pair,\n        uint256\n    );\n\n    constructor(address _feeToSetter) {\n        feeToSetter = _feeToSetter;\n    }\n\n    function allPairsLength() external view returns (uint256) {\n        return allPairs.length;\n    }\n\n    function createPair(\n        address tokenA,\n        address tokenB\n    ) external returns (address pair) {\n        require(\n            tokenA != tokenB,\n            \"SwapPairTokensFactory::createPair: IDENTICAL_ADDRESSES\"\n        );\n        (address token0, address token1) = tokenA < tokenB\n            ? (tokenA, tokenB)\n            : (tokenB, tokenA);\n        require(\n            tokenA != address(0),\n            \"SwapPairTokensFactory::createPair: ZERO_ADDRESS\"\n        );\n        require(\n            getPair[token0][token1] == address(0),\n            \"SwapPairTokensFactory::createPair: PAIR_EXISTS\"\n        ); // single check is sufficient\n        bytes memory bytecode = type(SwapPairTokens).creationCode;\n        bytes32 salt = keccak256(abi.encodePacked(token0, token1));\n        assembly {\n            pair := create2(0, add(bytecode, 32), mload(bytecode), salt)\n        }\n        SwapPairTokens(pair).initialize(token0, token1);\n\n        getPair[token0][token1] = pair;\n        getPair[token1][token0] = pair; // populate mapping in the reverse direction\n        allPairs.push(pair);\n        emit PairCreated(token0, token1, pair, allPairs.length);\n    }\n\n    function setFeeTo(address _feeTo) external {\n        require(\n            msg.sender == feeToSetter,\n            \"SwapPairTokensFactory::setFeeTo: FORBIDDEN\"\n        );\n        feeTo = _feeTo;\n    }\n\n    function setFeeToSetter(address _feeToSetter) external {\n        require(\n            msg.sender == feeToSetter,\n            \"SwapPairTokensFactory::setFeeToSetter: FORBIDDEN\"\n        );\n        feeToSetter = _feeToSetter;\n    }\n}\n"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\ninterface IERC20 {\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function totalSupply() external view returns (uint256);\n\n    function decimals() external view returns (uint256);\n\n    function balanceOf(address _owner) external view returns (uint256);\n\n    function allowance(\n        address _owner,\n        address _spender\n    ) external view returns (uint256);\n\n    function approve(address _spender, uint256 _value) external returns (bool);\n\n    function transfer(address _to, uint256 _value) external returns (bool);\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) external returns (bool);\n}\n"
    },
    "contracts/interfaces/IRToken.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\ninterface IRToken {\n    event Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _value\n    );\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n\n    event Deposit(address indexed _owner, uint256 _value);\n\n    event Withdraw(address indexed _owner, uint256 _value);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint256);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address _owner) external view returns (uint256);\n\n    function allowance(\n        address _owner,\n        address _spender\n    ) external view returns (uint256);\n\n    function approve(address _spender, uint256 _value) external returns (bool);\n\n    function transfer(address _to, uint256 _value) external returns (bool);\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) external returns (bool);\n\n    function deposit() external payable;\n\n    function withdraw(uint256 _value) external;\n}\n"
    },
    "contracts/interfaces/ISwapFactory.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\ninterface ISwapFactory {\n    event PairCreated(\n        address indexed token0,\n        address indexed token1,\n        address pair,\n        uint256\n    );\n\n    function feeTo() external view returns (address);\n\n    function feeToSetter() external view returns (address);\n\n    function getPair(\n        address _tokenA,\n        address _tokenB\n    ) external view returns (address pair);\n\n    function allPairs(uint256) external view returns (address pair);\n\n    function allPairsLength() external view returns (uint256);\n\n    function createPair(\n        address _tokenA,\n        address _tokenB\n    ) external returns (address pair);\n\n    function setFeeTo(address) external;\n\n    function setFeeToSetter(address) external;\n}\n"
    },
    "contracts/interfaces/ISwapPairTokens.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\ninterface ISwapPairTokens {\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n    event Burn(\n        address indexed sender,\n        uint256 amount0,\n        uint256 amount1,\n        address indexed to\n    );\n    event Swap(\n        address indexed sender,\n        uint256 amount0In,\n        uint256 amount1In,\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address indexed to\n    );\n\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint256);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address _owner) external view returns (uint256);\n\n    function allowance(\n        address _owner,\n        address _spender\n    ) external view returns (uint256);\n\n    function approve(address _spender, uint256 _value) external returns (bool);\n\n    function transfer(address _to, uint256 _value) external returns (bool);\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) external returns (bool);\n\n    function permit(\n        address _owner,\n        address _spender,\n        uint256 _value,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external;\n\n    function MINIMUM_LIQUIDITY() external view returns (uint256);\n\n    function factory() external view returns (address);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function getReserves()\n        external\n        view\n        returns (\n            uint112 _reserve0,\n            uint112 _reserve1,\n            uint32 _blockTimestampLast\n        );\n\n    function price0CumulativeLast() external view returns (uint256);\n\n    function price1CumulativeLast() external view returns (uint256);\n\n    function kLast() external view returns (uint256);\n\n    function mint(address _to) external returns (uint256 liquidity);\n\n    function burn(\n        address _to\n    ) external returns (uint256 amount0, uint256 amount1);\n\n    function swap(\n        uint256 _amount0Out,\n        uint256 _amount1Out,\n        address _to,\n        bytes calldata _data\n    ) external;\n\n    function skim(address _to) external;\n\n    function sync() external;\n\n    function initialize(address _token0, address _token1) external;\n}\n"
    },
    "contracts/interfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\ninterface IWETH {\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Deposit(address indexed account, uint256 amount);\n    event Withdrawal(address indexed account, uint256 amount);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint256);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address _owner) external view returns (uint256);\n\n    function allowance(\n        address _owner,\n        address _spender\n    ) external view returns (uint256);\n\n    function approve(address _spender, uint256 _value) external returns (bool);\n\n    function transfer(address _to, uint256 _value) external returns (bool);\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) external returns (bool);\n\n    function deposit() external payable;\n\n    function withdraw(uint256 _amount) external;\n}\n"
    },
    "contracts/libraries/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n// a library for performing various math operations\n\nlibrary Math {\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x < y ? x : y;\n    }\n\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n}\n"
    },
    "contracts/libraries/safeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/libraries/SwapLibrary.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\nimport \"../interfaces/ISwapPairTokens.sol\";\nimport \"../interfaces/ISwapFactory.sol\";\nimport \"../libraries/safeMath.sol\";\n\nlibrary SwapLibrary {\n    using SafeMath for uint256;\n\n    function sortTokens(\n        address _tokenA,\n        address _tokenB\n    ) internal pure returns (address token0, address token1) {\n        require(_tokenA != _tokenB, \"SwapLibrary: IDENTICAL_ADDRESSES\");\n        (token0, token1) = _tokenA < _tokenB\n            ? (_tokenA, _tokenB)\n            : (_tokenB, _tokenA);\n        require(token0 != address(0), \"SwapLibrary: ZERO_ADDRESS\");\n    }\n\n    // calculates the CREATE2 address for a pair without making any external calls\n    function pairFor(\n        address _factory,\n        address _tokenA,\n        address _tokenB\n    ) internal view returns (address pair) {\n        (address token0, address token1) = sortTokens(_tokenA, _tokenB);\n        pair = ISwapFactory(_factory).getPair(token0, token1);\n    }\n\n    // fetches and sorts the reserves for a pair\n    function getReserves(\n        address _factory,\n        address _tokenA,\n        address _tokenB\n    ) internal view returns (uint256 reserveA, uint256 reserveB) {\n        (address token0, ) = sortTokens(_tokenA, _tokenB);\n        (uint256 reserve0, uint256 reserve1, ) = ISwapPairTokens(\n            pairFor(_factory, _tokenA, _tokenB)\n        ).getReserves();\n        (reserveA, reserveB) = _tokenA == token0\n            ? (reserve0, reserve1)\n            : (reserve1, reserve0);\n    }\n\n    // given some amount of an asset and pair reserves, returns an equivalent amount of other asset\n    function quote(\n        uint256 _amountA,\n        uint256 _reserveA,\n        uint256 _reserveB\n    ) internal pure returns (uint256 amountB) {\n        require(_amountA > 0, \"SwapLibrary: INSUFFICIENT_AMOUNT\");\n        require(\n            _reserveA > 0 && _reserveB > 0,\n            \"SwapLibrary: INSUFFICIENT_LIQUIDITY\"\n        );\n        amountB = _amountA.mul(_reserveB) / _reserveA;\n    }\n\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(\n        uint256 _amountIn,\n        uint256 _reserveIn,\n        uint256 _reserveOut\n    ) internal pure returns (uint256 amountOut) {\n        require(_amountIn > 0, \"SwapLibrary: INSUFFICIENT_INPUT_AMOUNT\");\n        require(\n            _reserveIn > 0 && _reserveOut > 0,\n            \"SwapLibrary: INSUFFICIENT_LIQUIDITY\"\n        );\n        uint256 amountInWithFee = _amountIn.mul(997);\n        uint256 numerator = amountInWithFee.mul(_reserveOut);\n        uint256 denominator = _reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(\n        uint256 _amountOut,\n        uint256 _reserveIn,\n        uint256 _reserveOut\n    ) internal pure returns (uint256 amountIn) {\n        require(_amountOut > 0, \"SwapLibrary: INSUFFICIENT_OUTPUT_AMOUNT\");\n        require(\n            _reserveIn > 0 && _reserveOut > 0,\n            \"SwapLibrary: INSUFFICIENT_LIQUIDITY\"\n        );\n        uint256 numerator = _reserveIn.mul(_amountOut).mul(1000);\n        uint256 denominator = _reserveOut.sub(_amountOut).mul(997);\n        amountIn = (numerator / denominator).add(1);\n    }\n\n    // performs chained getAmountOut calculations on any number of pairs\n    function getAmountsOut(\n        address _factory,\n        uint256 _amountIn,\n        address[] memory _path\n    ) internal view returns (uint256[] memory amounts) {\n        require(_path.length >= 2, \"SwapLibrary: INVALID_PATH\");\n        amounts = new uint256[](_path.length);\n        amounts[0] = _amountIn;\n        for (uint256 i; i < _path.length - 1; i++) {\n            (uint256 reserveIn, uint256 reserveOut) = getReserves(\n                _factory,\n                _path[i],\n                _path[i + 1]\n            );\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n        }\n    }\n\n    // performs chained getAmountIn calculations on any number of pairs\n    function getAmountsIn(\n        address _factory,\n        uint256 _amountOut,\n        address[] memory _path\n    ) internal view returns (uint256[] memory amounts) {\n        require(_path.length >= 2, \"SwapLibrary: INVALID_PATH\");\n        amounts = new uint256[](_path.length);\n        amounts[amounts.length - 1] = _amountOut;\n        for (uint256 i = _path.length - 1; i > 0; i--) {\n            (uint256 reserveIn, uint256 reserveOut) = getReserves(\n                _factory,\n                _path[i - 1],\n                _path[i]\n            );\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\n        }\n    }\n}\n"
    },
    "contracts/libraries/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\nlibrary TransferHelper {\n    function safeApprove(address token, address to, uint256 value) internal {\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(0x095ea7b3, to, value)\n        );\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"TransferHelper: APPROVE_FAILED\"\n        );\n    }\n\n    function safeTransfer(address token, address to, uint256 value) internal {\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(0xa9059cbb, to, value)\n        );\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"TransferHelper: TRANSFER_FAILED\"\n        );\n    }\n\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(0x23b872dd, from, to, value)\n        );\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"TransferHelper: TRANSFER_FROM_FAILED\"\n        );\n    }\n\n    function safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(success, \"TransferHelper: ETH_TRANSFER_FAILED\");\n    }\n}\n"
    },
    "contracts/libraries/UQ112x112.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\n\n// range: [0, 2**112 - 1]\n// resolution: 1 / 2**112\n\nlibrary UQ112x112 {\n    uint224 constant Q112 = 2 ** 112;\n\n    // encode a uint112 as a UQ112x112\n    function encode(uint112 y) internal pure returns (uint224 z) {\n        z = uint224(y) * Q112; // never overflows\n    }\n\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\n    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {\n        z = x / uint224(y);\n    }\n}\n"
    },
    "contracts/oracle/SwapPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\nimport \"../libraries/SwapLibrary.sol\";\nimport \"../interfaces/ISwapPairTokens.sol\";\n\ncontract SwapPriceOracle {\n    address public immutable factory;\n    address public immutable WETH;\n\n    constructor(address _factory, address _WETH) {\n        factory = _factory;\n        WETH = _WETH;\n    }\n\n    // returns the price of A with precision of B\n    // A = price * ( B   )\n    function getPriceA(\n        address _tokenA,\n        address _tokenB\n    ) public view returns (uint256 priceA) {\n        address pair = SwapLibrary.pairFor(factory, _tokenA, _tokenB);\n\n        (uint reserveA, uint reserveB, uint timestamp) = ISwapPairTokens(pair)\n            .getReserves();\n        priceA = (reserveB / reserveA);\n    }\n\n    function getPriceB(\n        address _tokenA,\n        address _tokenB\n    ) public view returns (uint256 priceB) {\n        address pair = SwapLibrary.pairFor(factory, _tokenA, _tokenB);\n\n        (uint reserveA, uint reserveB, uint timestamp) = ISwapPairTokens(pair)\n            .getReserves();\n        priceB = (reserveA / reserveB);\n    }\n}\n"
    },
    "contracts/router/SwapRouter.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\nimport \"../libraries/SwapLibrary.sol\";\nimport \"../libraries/TransferHelper.sol\";\nimport \"../libraries/safeMath.sol\";\nimport \"../interfaces/ISwapFactory.sol\";\nimport \"../interfaces/ISwapPairTokens.sol\";\nimport \"../interfaces/IERC20.sol\";\nimport \"../interfaces/IWETH.sol\";\nimport \"../interfaces/IRToken.sol\";\n\ncontract SwapRouter {\n    using SafeMath for uint256;\n\n    address public immutable factory;\n    address public immutable WETH;\n\n    modifier ensure(uint256 deadline) {\n        require(deadline >= block.timestamp, \"EXPIRED\");\n        _;\n    }\n\n    constructor(address _factory, address _WETH) {\n        factory = _factory;\n        WETH = _WETH;\n    }\n\n    receive() external payable {\n        assert(msg.sender == WETH);\n        // only accept ETH via fallback from the WETH contract\n    }\n\n    function getLiquidityAmount(\n        address _user,\n        address _tokenA,\n        address _tokenB\n    ) public view returns (uint256 liquidityAmount) {\n        address pair = ISwapFactory(factory).getPair(_tokenA, _tokenB);\n        liquidityAmount = ISwapPairTokens(pair).balanceOf(_user);\n    }\n\n    /**\n     * @dev Add liquidity to a pool\n     * @param _tokenA - the first token of the pair\n     * @param _tokenB - the second token of the pair\n     * @param _amountAMin - the minimum amount of the first token to add as liquidity\n     * @param _amountBMin - the minimum amount of the second token to add as liquidity\n     * @param _amountADesired - the desired amount of the first token to add as liquidity\n     * @param _amountBDesired - the desired amount of the second token to add as liquidity\n     */\n    function _addLiquidity(\n        address _tokenA,\n        address _tokenB,\n        uint256 _amountADesired,\n        uint256 _amountBDesired,\n        uint256 _amountAMin,\n        uint256 _amountBMin\n    ) internal virtual returns (uint256 amountA, uint256 amountB) {\n        if (ISwapFactory(factory).getPair(_tokenA, _tokenB) == address(0)) {\n            ISwapFactory(factory).createPair(_tokenA, _tokenB);\n        }\n        (uint256 reserveA, uint256 reserveB) = SwapLibrary.getReserves(\n            factory,\n            _tokenA,\n            _tokenB\n        );\n\n        if (reserveA == 0 && reserveB == 0) {\n            (amountA, amountB) = (_amountADesired, _amountBDesired);\n        } else {\n            uint256 amountBOptimal = SwapLibrary.quote(\n                _amountADesired,\n                reserveA,\n                reserveB\n            );\n            if (amountBOptimal <= _amountBDesired) {\n                require(amountBOptimal >= _amountBMin, \"INSUFFICIENT_B_AMOUNT\");\n                (amountA, amountB) = (_amountADesired, amountBOptimal);\n            } else {\n                uint256 amountAOptimal = SwapLibrary.quote(\n                    _amountBDesired,\n                    reserveB,\n                    reserveA\n                );\n                assert(amountAOptimal <= _amountADesired);\n                require(amountAOptimal >= _amountAMin, \"INSUFFICIENT_A_AMOUNT\");\n                (amountA, amountB) = (amountAOptimal, _amountBDesired);\n            }\n        }\n    }\n\n    function addLiquidity(\n        address _tokenA,\n        address _tokenB,\n        uint256 _amountADesired,\n        uint256 _amountBDesired,\n        uint256 _amountAMin,\n        uint256 _amountBMin,\n        address _to,\n        uint256 _deadline\n    )\n        external\n        virtual\n        ensure(_deadline)\n        returns (uint256 amountA, uint256 amountB, uint256 liquidity)\n    {\n        (amountA, amountB) = _addLiquidity(\n            _tokenA,\n            _tokenB,\n            _amountADesired,\n            _amountBDesired,\n            _amountAMin,\n            _amountBMin\n        );\n\n        address pair = SwapLibrary.pairFor(factory, _tokenA, _tokenB);\n        TransferHelper.safeTransferFrom(_tokenA, msg.sender, pair, amountA);\n        TransferHelper.safeTransferFrom(_tokenB, msg.sender, pair, amountB);\n        liquidity = ISwapPairTokens(pair).mint(_to);\n    }\n\n    function addLiquidityETH(\n        address _token,\n        uint256 _amountTokenDesired,\n        uint256 _amountTokenMin,\n        uint256 _amountETHMin,\n        address _to,\n        uint256 _deadline\n    )\n        external\n        payable\n        virtual\n        ensure(_deadline)\n        returns (uint256 amountToken, uint256 amountETH, uint256 liquidity)\n    {\n        (amountToken, amountETH) = _addLiquidity(\n            _token,\n            WETH,\n            _amountTokenDesired,\n            msg.value,\n            _amountTokenMin,\n            _amountETHMin\n        );\n        address pair = SwapLibrary.pairFor(factory, _token, WETH);\n        TransferHelper.safeTransferFrom(_token, msg.sender, pair, amountToken);\n        IWETH(WETH).deposit{value: amountETH}();\n        assert(IWETH(WETH).transfer(pair, amountETH));\n        liquidity = ISwapPairTokens(pair).mint(_to);\n        if (msg.value > amountETH) {\n            TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);\n        }\n    }\n\n    function removeLiquidity(\n        address _tokenA,\n        address _tokenB,\n        uint256 _liquidity,\n        uint256 _amountAMin,\n        uint256 _amountBMin,\n        address _to,\n        uint256 _deadline\n    )\n        public\n        virtual\n        ensure(_deadline)\n        returns (uint256 amountA, uint256 amountB)\n    {\n        address pair = SwapLibrary.pairFor(factory, _tokenA, _tokenB);\n        ISwapPairTokens(pair).transferFrom(msg.sender, pair, _liquidity); // send liquidity to pair\n        (uint256 amount0, uint256 amount1) = ISwapPairTokens(pair).burn(_to);\n        (address token0, ) = SwapLibrary.sortTokens(_tokenA, _tokenB);\n        (amountA, amountB) = _tokenA == token0\n            ? (amount0, amount1)\n            : (amount1, amount0);\n\n        require(amountA >= _amountAMin, \"INSUFFICIENT_A_AMOUNT\");\n        require(amountB >= _amountBMin, \"INSUFFICIENT_B_AMOUNT\");\n    }\n\n    function removeLiquidityETH(\n        address _token,\n        uint256 _liquidity,\n        uint256 _amountTokenMin,\n        uint256 _amountETHMin,\n        address _to,\n        uint256 _deadline\n    )\n        public\n        virtual\n        ensure(_deadline)\n        returns (uint256 amountToken, uint256 amountETH)\n    {\n        (amountToken, amountETH) = removeLiquidity(\n            _token,\n            WETH,\n            _liquidity,\n            _amountTokenMin,\n            _amountETHMin,\n            address(this),\n            _deadline\n        );\n        TransferHelper.safeTransfer(_token, _to, amountToken);\n        IWETH(WETH).withdraw(amountETH);\n        TransferHelper.safeTransferETH(_to, amountETH);\n    }\n\n    function _swap(\n        uint256[] memory _amounts,\n        address[] memory _path,\n        address _to\n    ) internal virtual {\n        for (uint256 i; i < _path.length - 1; i++) {\n            (address input, address output) = (_path[i], _path[i + 1]);\n            (address token0, ) = SwapLibrary.sortTokens(input, output);\n            uint256 amountOut = _amounts[i + 1];\n            (uint256 amount0Out, uint256 amount1Out) = input == token0\n                ? (uint256(0), amountOut)\n                : (amountOut, uint256(0));\n            address to = i < _path.length - 2\n                ? SwapLibrary.pairFor(factory, output, _path[i + 2])\n                : _to;\n            ISwapPairTokens(SwapLibrary.pairFor(factory, input, output)).swap(\n                amount0Out,\n                amount1Out,\n                to,\n                new bytes(0)\n            );\n        }\n    }\n\n    function swapExactTokensForTokens(\n        uint256 _amountIn,\n        uint256 _amountOutMin,\n        address[] calldata _path,\n        address _to,\n        uint256 _deadline\n    ) external virtual ensure(_deadline) returns (uint256[] memory amounts) {\n        amounts = SwapLibrary.getAmountsOut(factory, _amountIn, _path);\n        require(\n            amounts[amounts.length - 1] >= _amountOutMin,\n            \"INSUFFICIENT_OUTPUT_AMOUNT\"\n        );\n        TransferHelper.safeTransferFrom(\n            _path[0],\n            msg.sender,\n            SwapLibrary.pairFor(factory, _path[0], _path[1]),\n            amounts[0]\n        );\n        _swap(amounts, _path, _to);\n    }\n\n    function swapTokensForExactTokens(\n        uint256 _amountOut,\n        uint256 _amountInMax,\n        address[] calldata _path,\n        address _to,\n        uint256 _deadline\n    ) external virtual ensure(_deadline) returns (uint256[] memory amounts) {\n        amounts = SwapLibrary.getAmountsIn(factory, _amountOut, _path);\n        require(amounts[0] <= _amountInMax, \"EXCESSIVE_INPUT_AMOUNT\");\n        TransferHelper.safeTransferFrom(\n            _path[0],\n            msg.sender,\n            SwapLibrary.pairFor(factory, _path[0], _path[1]),\n            amounts[0]\n        );\n        _swap(amounts, _path, _to);\n    }\n\n    function swapExactETHForTokens(\n        uint256 _amountOutMin,\n        address[] calldata _path,\n        address _to,\n        uint256 _deadline\n    )\n        external\n        payable\n        virtual\n        ensure(_deadline)\n        returns (uint256[] memory amounts)\n    {\n        require(_path[0] == WETH, \"INVALID_PATH\");\n        amounts = SwapLibrary.getAmountsOut(factory, msg.value, _path);\n        require(\n            amounts[amounts.length - 1] >= _amountOutMin,\n            \"INSUFFICIENT_OUTPUT_AMOUNT\"\n        );\n        IWETH(WETH).deposit{value: amounts[0]}();\n        assert(\n            IWETH(WETH).transfer(\n                SwapLibrary.pairFor(factory, _path[0], _path[1]),\n                amounts[0]\n            )\n        );\n        _swap(amounts, _path, _to);\n    }\n\n    function swapETHForExactTokens(\n        uint256 _amountOut,\n        address[] calldata _path,\n        address _to,\n        uint256 _deadline\n    )\n        external\n        payable\n        virtual\n        ensure(_deadline)\n        returns (uint256[] memory amounts)\n    {\n        require(_path[0] == WETH, \"INVALID_PATH\");\n        amounts = SwapLibrary.getAmountsIn(factory, _amountOut, _path);\n        require(amounts[0] <= msg.value, \"EXCESSIVE_INPUT_AMOUNT\");\n        IWETH(WETH).deposit{value: amounts[0]}();\n        assert(\n            IWETH(WETH).transfer(\n                SwapLibrary.pairFor(factory, _path[0], _path[1]),\n                amounts[0]\n            )\n        );\n        _swap(amounts, _path, _to);\n        if (msg.value > amounts[0])\n            TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]);\n    }\n\n    function swapTokensForExactETH(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata _path,\n        address _to,\n        uint256 _deadline\n    ) external virtual ensure(_deadline) returns (uint256[] memory amounts) {\n        require(_path[_path.length - 1] == WETH, \"INVALID_PATH\");\n        amounts = SwapLibrary.getAmountsIn(factory, amountOut, _path);\n        require(amounts[0] <= amountInMax, \"EXCESSIVE_INPUT_AMOUNT\");\n        TransferHelper.safeTransferFrom(\n            _path[0],\n            msg.sender,\n            SwapLibrary.pairFor(factory, _path[0], _path[1]),\n            amounts[0]\n        );\n        _swap(amounts, _path, address(this));\n        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\n        TransferHelper.safeTransferETH(_to, amounts[amounts.length - 1]);\n    }\n\n    function swapExactTokensForETH(\n        uint256 _amountIn,\n        uint256 _amountOutMin,\n        address[] calldata _path,\n        address _to,\n        uint256 _deadline\n    ) external virtual ensure(_deadline) returns (uint256[] memory amounts) {\n        require(_path[_path.length - 1] == WETH, \"INVALID_PATH\");\n        amounts = SwapLibrary.getAmountsOut(factory, _amountIn, _path);\n        require(\n            amounts[amounts.length - 1] >= _amountOutMin,\n            \"INSUFFICIENT_OUTPUT_AMOUNT\"\n        );\n        TransferHelper.safeTransferFrom(\n            _path[0],\n            msg.sender,\n            SwapLibrary.pairFor(factory, _path[0], _path[1]),\n            amounts[0]\n        );\n        _swap(amounts, _path, address(this));\n        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\n        TransferHelper.safeTransferETH(_to, amounts[amounts.length - 1]);\n    }\n\n    function getReserve(\n        address _tokenA,\n        address _tokenB\n    ) public view returns (uint256 reserveA, uint256 reserveB) {\n        (reserveA, reserveB) = SwapLibrary.getReserves(\n            factory,\n            _tokenA,\n            _tokenB\n        );\n    }\n\n    function quote(\n        uint256 _amountA,\n        uint256 _reserveA,\n        uint256 _reserveB\n    ) public pure virtual returns (uint256 amountB) {\n        return SwapLibrary.quote(_amountA, _reserveA, _reserveB);\n    }\n\n    function getAmountOut(\n        uint256 _amountIn,\n        uint256 _reserveIn,\n        uint256 _reserveOut\n    ) public pure virtual returns (uint256 amountOut) {\n        return SwapLibrary.getAmountOut(_amountIn, _reserveIn, _reserveOut);\n    }\n\n    function getAmountIn(\n        uint256 _amountOut,\n        uint256 _reserveIn,\n        uint256 _reserveOut\n    ) public pure virtual returns (uint256 amountIn) {\n        return SwapLibrary.getAmountIn(_amountOut, _reserveIn, _reserveOut);\n    }\n\n    function getAmountsOut(\n        uint256 _amountIn,\n        address[] memory _path\n    ) public view virtual returns (uint256[] memory amounts) {\n        return SwapLibrary.getAmountsOut(factory, _amountIn, _path);\n    }\n\n    function getAmountsIn(\n        uint256 _amountOut,\n        address[] memory _path\n    ) public view virtual returns (uint256[] memory amounts) {\n        return SwapLibrary.getAmountsIn(factory, _amountOut, _path);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}