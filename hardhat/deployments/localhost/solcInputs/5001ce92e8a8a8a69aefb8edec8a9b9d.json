{
  "language": "Solidity",
  "sources": {
    "contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\ninterface IERC20 {\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function totalSupply() external view returns (uint256);\n\n    function decimals() external view returns (uint256);\n\n    function balanceOf(address _owner) external view returns (uint256);\n\n    function allowance(\n        address _owner,\n        address _spender\n    ) external view returns (uint256);\n\n    function approve(address _spender, uint256 _value) external returns (bool);\n\n    function transfer(address _to, uint256 _value) external returns (bool);\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) external returns (bool);\n}\n"
    },
    "contracts/interfaces/IRToken.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\ninterface IRToken {\n    event Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _value\n    );\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n\n    event Deposit(address indexed _owner, uint256 _value);\n\n    event Withdraw(address indexed _owner, uint256 _value);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint256);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address _owner) external view returns (uint256);\n\n    function allowance(\n        address _owner,\n        address _spender\n    ) external view returns (uint256);\n\n    function approve(address _spender, uint256 _value) external returns (bool);\n\n    function transfer(address _to, uint256 _value) external returns (bool);\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) external returns (bool);\n\n    function deposit() external payable;\n\n    function withdraw(uint256 _value) external;\n}\n"
    },
    "contracts/interfaces/ISwapFactory.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\ninterface ISwapFactory {\n    event PairCreated(\n        address indexed token0,\n        address indexed token1,\n        address pair,\n        uint256\n    );\n\n    function feeTo() external view returns (address);\n\n    function feeToSetter() external view returns (address);\n\n    function getPair(\n        address _tokenA,\n        address _tokenB\n    ) external view returns (address pair);\n\n    function allPairs(uint256) external view returns (address pair);\n\n    function allPairsLength() external view returns (uint256);\n\n    function createPair(\n        address _tokenA,\n        address _tokenB\n    ) external returns (address pair);\n\n    function setFeeTo(address) external;\n\n    function setFeeToSetter(address) external;\n}\n"
    },
    "contracts/interfaces/ISwapPairTokens.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\ninterface ISwapPairTokens {\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n    event Burn(\n        address indexed sender,\n        uint256 amount0,\n        uint256 amount1,\n        address indexed to\n    );\n    event Swap(\n        address indexed sender,\n        uint256 amount0In,\n        uint256 amount1In,\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address indexed to\n    );\n\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint256);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address _owner) external view returns (uint256);\n\n    function allowance(\n        address _owner,\n        address _spender\n    ) external view returns (uint256);\n\n    function approve(address _spender, uint256 _value) external returns (bool);\n\n    function transfer(address _to, uint256 _value) external returns (bool);\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) external returns (bool);\n\n    function permit(\n        address _owner,\n        address _spender,\n        uint256 _value,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external;\n\n    function MINIMUM_LIQUIDITY() external view returns (uint256);\n\n    function factory() external view returns (address);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function getReserves()\n        external\n        view\n        returns (\n            uint112 _reserve0,\n            uint112 _reserve1,\n            uint32 _blockTimestampLast\n        );\n\n    function price0CumulativeLast() external view returns (uint256);\n\n    function price1CumulativeLast() external view returns (uint256);\n\n    function kLast() external view returns (uint256);\n\n    function mint(address _to) external returns (uint256 liquidity);\n\n    function burn(\n        address _to\n    ) external returns (uint256 amount0, uint256 amount1);\n\n    function swap(\n        uint256 _amount0Out,\n        uint256 _amount1Out,\n        address _to,\n        bytes calldata _data\n    ) external;\n\n    function skim(address _to) external;\n\n    function sync() external;\n\n    function initialize(address _token0, address _token1) external;\n}\n"
    },
    "contracts/interfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\ninterface IWETH {\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Deposit(address indexed account, uint256 amount);\n    event Withdrawal(address indexed account, uint256 amount);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint256);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address _owner) external view returns (uint256);\n\n    function allowance(\n        address _owner,\n        address _spender\n    ) external view returns (uint256);\n\n    function approve(address _spender, uint256 _value) external returns (bool);\n\n    function transfer(address _to, uint256 _value) external returns (bool);\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) external returns (bool);\n\n    function deposit() external payable;\n\n    function withdraw(uint256 _amount) external;\n}\n"
    },
    "contracts/libraries/safeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/libraries/SwapLibrary.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\nimport \"../interfaces/ISwapPairTokens.sol\";\nimport \"../interfaces/ISwapFactory.sol\";\nimport \"../libraries/safeMath.sol\";\n\nlibrary SwapLibrary {\n    using SafeMath for uint256;\n\n    function sortTokens(\n        address _tokenA,\n        address _tokenB\n    ) internal pure returns (address token0, address token1) {\n        require(_tokenA != _tokenB, \"SwapLibrary: IDENTICAL_ADDRESSES\");\n        (token0, token1) = _tokenA < _tokenB\n            ? (_tokenA, _tokenB)\n            : (_tokenB, _tokenA);\n        require(token0 != address(0), \"SwapLibrary: ZERO_ADDRESS\");\n    }\n\n    // calculates the CREATE2 address for a pair without making any external calls\n    function pairFor(\n        address _factory,\n        address _tokenA,\n        address _tokenB\n    ) internal view returns (address pair) {\n        (address token0, address token1) = sortTokens(_tokenA, _tokenB);\n        pair = ISwapFactory(_factory).getPair(token0, token1);\n    }\n\n    // fetches and sorts the reserves for a pair\n    function getReserves(\n        address _factory,\n        address _tokenA,\n        address _tokenB\n    ) internal view returns (uint256 reserveA, uint256 reserveB) {\n        (address token0, ) = sortTokens(_tokenA, _tokenB);\n        (uint256 reserve0, uint256 reserve1, ) = ISwapPairTokens(\n            pairFor(_factory, _tokenA, _tokenB)\n        ).getReserves();\n        (reserveA, reserveB) = _tokenA == token0\n            ? (reserve0, reserve1)\n            : (reserve1, reserve0);\n    }\n\n    // given some amount of an asset and pair reserves, returns an equivalent amount of other asset\n    function quote(\n        uint256 _amountA,\n        uint256 _reserveA,\n        uint256 _reserveB\n    ) internal pure returns (uint256 amountB) {\n        require(_amountA > 0, \"SwapLibrary: INSUFFICIENT_AMOUNT\");\n        require(\n            _reserveA > 0 && _reserveB > 0,\n            \"SwapLibrary: INSUFFICIENT_LIQUIDITY\"\n        );\n        amountB = _amountA.mul(_reserveB) / _reserveA;\n    }\n\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(\n        uint256 _amountIn,\n        uint256 _reserveIn,\n        uint256 _reserveOut\n    ) internal pure returns (uint256 amountOut) {\n        require(_amountIn > 0, \"SwapLibrary: INSUFFICIENT_INPUT_AMOUNT\");\n        require(\n            _reserveIn > 0 && _reserveOut > 0,\n            \"SwapLibrary: INSUFFICIENT_LIQUIDITY\"\n        );\n        uint256 amountInWithFee = _amountIn.mul(997);\n        uint256 numerator = amountInWithFee.mul(_reserveOut);\n        uint256 denominator = _reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(\n        uint256 _amountOut,\n        uint256 _reserveIn,\n        uint256 _reserveOut\n    ) internal pure returns (uint256 amountIn) {\n        require(_amountOut > 0, \"SwapLibrary: INSUFFICIENT_OUTPUT_AMOUNT\");\n        require(\n            _reserveIn > 0 && _reserveOut > 0,\n            \"SwapLibrary: INSUFFICIENT_LIQUIDITY\"\n        );\n        uint256 numerator = _reserveIn.mul(_amountOut).mul(1000);\n        uint256 denominator = _reserveOut.sub(_amountOut).mul(997);\n        amountIn = (numerator / denominator).add(1);\n    }\n\n    // performs chained getAmountOut calculations on any number of pairs\n    function getAmountsOut(\n        address _factory,\n        uint256 _amountIn,\n        address[] memory _path\n    ) internal view returns (uint256[] memory amounts) {\n        require(_path.length >= 2, \"SwapLibrary: INVALID_PATH\");\n        amounts = new uint256[](_path.length);\n        amounts[0] = _amountIn;\n        for (uint256 i; i < _path.length - 1; i++) {\n            (uint256 reserveIn, uint256 reserveOut) = getReserves(\n                _factory,\n                _path[i],\n                _path[i + 1]\n            );\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n        }\n    }\n\n    // performs chained getAmountIn calculations on any number of pairs\n    function getAmountsIn(\n        address _factory,\n        uint256 _amountOut,\n        address[] memory _path\n    ) internal view returns (uint256[] memory amounts) {\n        require(_path.length >= 2, \"SwapLibrary: INVALID_PATH\");\n        amounts = new uint256[](_path.length);\n        amounts[amounts.length - 1] = _amountOut;\n        for (uint256 i = _path.length - 1; i > 0; i--) {\n            (uint256 reserveIn, uint256 reserveOut) = getReserves(\n                _factory,\n                _path[i - 1],\n                _path[i]\n            );\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\n        }\n    }\n}\n"
    },
    "contracts/libraries/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\nlibrary TransferHelper {\n    function safeApprove(address token, address to, uint256 value) internal {\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(0x095ea7b3, to, value)\n        );\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"TransferHelper: APPROVE_FAILED\"\n        );\n    }\n\n    function safeTransfer(address token, address to, uint256 value) internal {\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(0xa9059cbb, to, value)\n        );\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"TransferHelper: TRANSFER_FAILED\"\n        );\n    }\n\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(0x23b872dd, from, to, value)\n        );\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"TransferHelper: TRANSFER_FROM_FAILED\"\n        );\n    }\n\n    function safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(success, \"TransferHelper: ETH_TRANSFER_FAILED\");\n    }\n}\n"
    },
    "contracts/router/SwapRouter.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\nimport \"../libraries/SwapLibrary.sol\";\nimport \"../libraries/TransferHelper.sol\";\nimport \"../libraries/safeMath.sol\";\nimport \"../interfaces/ISwapFactory.sol\";\nimport \"../interfaces/ISwapPairTokens.sol\";\nimport \"../interfaces/IERC20.sol\";\nimport \"../interfaces/IWETH.sol\";\nimport \"../interfaces/IRToken.sol\";\n\ncontract SwapRouter {\n    using SafeMath for uint256;\n\n    address public immutable factory;\n    address public immutable WETH;\n\n    modifier ensure(uint256 deadline) {\n        require(deadline >= block.timestamp, \"EXPIRED\");\n        _;\n    }\n\n    constructor(address _factory, address _WETH) {\n        factory = _factory;\n        WETH = _WETH;\n    }\n\n    receive() external payable {\n        assert(msg.sender == WETH);\n        // only accept ETH via fallback from the WETH contract\n    }\n\n    function getLiquidityAmount(\n        address _user,\n        address _tokenA,\n        address _tokenB\n    ) public view returns (uint256 liquidityAmount) {\n        address pair = ISwapFactory(factory).getPair(_tokenA, _tokenB);\n        uint256 balance = ISwapPairTokens(pair).balanceOf(_user);\n\n        if (balance > 0) {\n            liquidityAmount = balance;\n        } else {\n            liquidityAmount = 0;\n        }\n    }\n\n    /**\n     * @dev Add liquidity to a pool\n     * @param _tokenA - the first token of the pair\n     * @param _tokenB - the second token of the pair\n     * @param _amountAMin - the minimum amount of the first token to add as liquidity\n     * @param _amountBMin - the minimum amount of the second token to add as liquidity\n     * @param _amountADesired - the desired amount of the first token to add as liquidity\n     * @param _amountBDesired - the desired amount of the second token to add as liquidity\n     */\n    function _addLiquidity(\n        address _tokenA,\n        address _tokenB,\n        uint256 _amountADesired,\n        uint256 _amountBDesired,\n        uint256 _amountAMin,\n        uint256 _amountBMin\n    ) internal virtual returns (uint256 amountA, uint256 amountB) {\n        if (ISwapFactory(factory).getPair(_tokenA, _tokenB) == address(0)) {\n            ISwapFactory(factory).createPair(_tokenA, _tokenB);\n        }\n        (uint256 reserveA, uint256 reserveB) = SwapLibrary.getReserves(\n            factory,\n            _tokenA,\n            _tokenB\n        );\n\n        if (reserveA == 0 && reserveB == 0) {\n            (amountA, amountB) = (_amountADesired, _amountBDesired);\n        } else {\n            uint256 amountBOptimal = SwapLibrary.quote(\n                _amountADesired,\n                reserveA,\n                reserveB\n            );\n            if (amountBOptimal <= _amountBDesired) {\n                require(amountBOptimal >= _amountBMin, \"INSUFFICIENT_B_AMOUNT\");\n                (amountA, amountB) = (_amountADesired, amountBOptimal);\n            } else {\n                uint256 amountAOptimal = SwapLibrary.quote(\n                    _amountBDesired,\n                    reserveB,\n                    reserveA\n                );\n                assert(amountAOptimal <= _amountADesired);\n                require(amountAOptimal >= _amountAMin, \"INSUFFICIENT_A_AMOUNT\");\n                (amountA, amountB) = (amountAOptimal, _amountBDesired);\n            }\n        }\n    }\n\n    function addLiquidity(\n        address _tokenA,\n        address _tokenB,\n        uint256 _amountADesired,\n        uint256 _amountBDesired,\n        uint256 _amountAMin,\n        uint256 _amountBMin,\n        address _to,\n        uint256 _deadline\n    )\n        external\n        virtual\n        ensure(_deadline)\n        returns (uint256 amountA, uint256 amountB, uint256 liquidity)\n    {\n        (amountA, amountB) = _addLiquidity(\n            _tokenA,\n            _tokenB,\n            _amountADesired,\n            _amountBDesired,\n            _amountAMin,\n            _amountBMin\n        );\n\n        address pair = SwapLibrary.pairFor(factory, _tokenA, _tokenB);\n        TransferHelper.safeTransferFrom(_tokenA, msg.sender, pair, amountA);\n        TransferHelper.safeTransferFrom(_tokenB, msg.sender, pair, amountB);\n        liquidity = ISwapPairTokens(pair).mint(_to);\n    }\n\n    function addLiquidityETH(\n        address _token,\n        uint256 _amountTokenDesired,\n        uint256 _amountTokenMin,\n        uint256 _amountETHMin,\n        address _to,\n        uint256 _deadline\n    )\n        external\n        payable\n        virtual\n        ensure(_deadline)\n        returns (uint256 amountToken, uint256 amountETH, uint256 liquidity)\n    {\n        (amountToken, amountETH) = _addLiquidity(\n            _token,\n            WETH,\n            _amountTokenDesired,\n            msg.value,\n            _amountTokenMin,\n            _amountETHMin\n        );\n        address pair = SwapLibrary.pairFor(factory, _token, WETH);\n        TransferHelper.safeTransferFrom(_token, msg.sender, pair, amountToken);\n        IWETH(WETH).deposit{value: amountETH}();\n        assert(IWETH(WETH).transfer(pair, amountETH));\n        liquidity = ISwapPairTokens(pair).mint(_to);\n        if (msg.value > amountETH) {\n            TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);\n        }\n    }\n\n    function removeLiquidity(\n        address _tokenA,\n        address _tokenB,\n        uint256 _liquidity,\n        uint256 _amountAMin,\n        uint256 _amountBMin,\n        address _to,\n        uint256 _deadline\n    )\n        public\n        virtual\n        ensure(_deadline)\n        returns (uint256 amountA, uint256 amountB)\n    {\n        address pair = SwapLibrary.pairFor(factory, _tokenA, _tokenB);\n        ISwapPairTokens(pair).transferFrom(msg.sender, pair, _liquidity); // send liquidity to pair\n        (uint256 amount0, uint256 amount1) = ISwapPairTokens(pair).burn(_to);\n        (address token0, ) = SwapLibrary.sortTokens(_tokenA, _tokenB);\n        (amountA, amountB) = _tokenA == token0\n            ? (amount0, amount1)\n            : (amount1, amount0);\n\n        require(amountA >= _amountAMin, \"INSUFFICIENT_A_AMOUNT\");\n        require(amountB >= _amountBMin, \"INSUFFICIENT_B_AMOUNT\");\n    }\n\n    function removeLiquidityETH(\n        address _token,\n        uint256 _liquidity,\n        uint256 _amountTokenMin,\n        uint256 _amountETHMin,\n        address _to,\n        uint256 _deadline\n    )\n        public\n        virtual\n        ensure(_deadline)\n        returns (uint256 amountToken, uint256 amountETH)\n    {\n        (amountToken, amountETH) = removeLiquidity(\n            _token,\n            WETH,\n            _liquidity,\n            _amountTokenMin,\n            _amountETHMin,\n            address(this),\n            _deadline\n        );\n        TransferHelper.safeTransfer(_token, _to, amountToken);\n        IWETH(WETH).withdraw(amountETH);\n        TransferHelper.safeTransferETH(_to, amountETH);\n    }\n\n    function _swap(\n        uint256[] memory _amounts,\n        address[] memory _path,\n        address _to\n    ) internal virtual {\n        for (uint256 i; i < _path.length - 1; i++) {\n            (address input, address output) = (_path[i], _path[i + 1]);\n            (address token0, ) = SwapLibrary.sortTokens(input, output);\n            uint256 amountOut = _amounts[i + 1];\n            (uint256 amount0Out, uint256 amount1Out) = input == token0\n                ? (uint256(0), amountOut)\n                : (amountOut, uint256(0));\n            address to = i < _path.length - 2\n                ? SwapLibrary.pairFor(factory, output, _path[i + 2])\n                : _to;\n            ISwapPairTokens(SwapLibrary.pairFor(factory, input, output)).swap(\n                amount0Out,\n                amount1Out,\n                to,\n                new bytes(0)\n            );\n        }\n    }\n\n    function swapExactTokensForTokens(\n        uint256 _amountIn,\n        uint256 _amountOutMin,\n        address[] calldata _path,\n        address _to,\n        uint256 _deadline\n    ) external virtual ensure(_deadline) returns (uint256[] memory amounts) {\n        amounts = SwapLibrary.getAmountsOut(factory, _amountIn, _path);\n        require(\n            amounts[amounts.length - 1] >= _amountOutMin,\n            \"INSUFFICIENT_OUTPUT_AMOUNT\"\n        );\n        TransferHelper.safeTransferFrom(\n            _path[0],\n            msg.sender,\n            SwapLibrary.pairFor(factory, _path[0], _path[1]),\n            amounts[0]\n        );\n        _swap(amounts, _path, _to);\n    }\n\n    function swapTokensForExactTokens(\n        uint256 _amountOut,\n        uint256 _amountInMax,\n        address[] calldata _path,\n        address _to,\n        uint256 _deadline\n    ) external virtual ensure(_deadline) returns (uint256[] memory amounts) {\n        amounts = SwapLibrary.getAmountsIn(factory, _amountOut, _path);\n        require(amounts[0] <= _amountInMax, \"EXCESSIVE_INPUT_AMOUNT\");\n        TransferHelper.safeTransferFrom(\n            _path[0],\n            msg.sender,\n            SwapLibrary.pairFor(factory, _path[0], _path[1]),\n            amounts[0]\n        );\n        _swap(amounts, _path, _to);\n    }\n\n    function swapExactETHForTokens(\n        uint256 _amountOutMin,\n        address[] calldata _path,\n        address _to,\n        uint256 _deadline\n    )\n        external\n        payable\n        virtual\n        ensure(_deadline)\n        returns (uint256[] memory amounts)\n    {\n        require(_path[0] == WETH, \"INVALID_PATH\");\n        amounts = SwapLibrary.getAmountsOut(factory, msg.value, _path);\n        require(\n            amounts[amounts.length - 1] >= _amountOutMin,\n            \"INSUFFICIENT_OUTPUT_AMOUNT\"\n        );\n        IWETH(WETH).deposit{value: amounts[0]}();\n        assert(\n            IWETH(WETH).transfer(\n                SwapLibrary.pairFor(factory, _path[0], _path[1]),\n                amounts[0]\n            )\n        );\n        _swap(amounts, _path, _to);\n    }\n\n    function swapETHForExactTokens(\n        uint256 _amountOut,\n        address[] calldata _path,\n        address _to,\n        uint256 _deadline\n    )\n        external\n        payable\n        virtual\n        ensure(_deadline)\n        returns (uint256[] memory amounts)\n    {\n        require(_path[0] == WETH, \"INVALID_PATH\");\n        amounts = SwapLibrary.getAmountsIn(factory, _amountOut, _path);\n        require(amounts[0] <= msg.value, \"EXCESSIVE_INPUT_AMOUNT\");\n        IWETH(WETH).deposit{value: amounts[0]}();\n        assert(\n            IWETH(WETH).transfer(\n                SwapLibrary.pairFor(factory, _path[0], _path[1]),\n                amounts[0]\n            )\n        );\n        _swap(amounts, _path, _to);\n        if (msg.value > amounts[0])\n            TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]);\n    }\n\n    function swapTokensForExactETH(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata _path,\n        address _to,\n        uint256 _deadline\n    ) external virtual ensure(_deadline) returns (uint256[] memory amounts) {\n        require(_path[_path.length - 1] == WETH, \"INVALID_PATH\");\n        amounts = SwapLibrary.getAmountsIn(factory, amountOut, _path);\n        require(amounts[0] <= amountInMax, \"EXCESSIVE_INPUT_AMOUNT\");\n        TransferHelper.safeTransferFrom(\n            _path[0],\n            msg.sender,\n            SwapLibrary.pairFor(factory, _path[0], _path[1]),\n            amounts[0]\n        );\n        _swap(amounts, _path, address(this));\n        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\n        TransferHelper.safeTransferETH(_to, amounts[amounts.length - 1]);\n    }\n\n    function swapExactTokensForETH(\n        uint256 _amountIn,\n        uint256 _amountOutMin,\n        address[] calldata _path,\n        address _to,\n        uint256 _deadline\n    ) external virtual ensure(_deadline) returns (uint256[] memory amounts) {\n        require(_path[_path.length - 1] == WETH, \"INVALID_PATH\");\n        amounts = SwapLibrary.getAmountsOut(factory, _amountIn, _path);\n        require(\n            amounts[amounts.length - 1] >= _amountOutMin,\n            \"INSUFFICIENT_OUTPUT_AMOUNT\"\n        );\n        TransferHelper.safeTransferFrom(\n            _path[0],\n            msg.sender,\n            SwapLibrary.pairFor(factory, _path[0], _path[1]),\n            amounts[0]\n        );\n        _swap(amounts, _path, address(this));\n        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\n        TransferHelper.safeTransferETH(_to, amounts[amounts.length - 1]);\n    }\n\n    function getReserve(\n        address _tokenA,\n        address _tokenB\n    ) public view returns (uint256 reserveA, uint256 reserveB) {\n        (reserveA, reserveB) = SwapLibrary.getReserves(\n            factory,\n            _tokenA,\n            _tokenB\n        );\n    }\n\n    function quote(\n        uint256 _amountA,\n        uint256 _reserveA,\n        uint256 _reserveB\n    ) public pure virtual returns (uint256 amountB) {\n        return SwapLibrary.quote(_amountA, _reserveA, _reserveB);\n    }\n\n    function getAmountOut(\n        uint256 _amountIn,\n        uint256 _reserveIn,\n        uint256 _reserveOut\n    ) public pure virtual returns (uint256 amountOut) {\n        return SwapLibrary.getAmountOut(_amountIn, _reserveIn, _reserveOut);\n    }\n\n    function getAmountIn(\n        uint256 _amountOut,\n        uint256 _reserveIn,\n        uint256 _reserveOut\n    ) public pure virtual returns (uint256 amountIn) {\n        return SwapLibrary.getAmountIn(_amountOut, _reserveIn, _reserveOut);\n    }\n\n    function getAmountsOut(\n        uint256 _amountIn,\n        address[] memory _path\n    ) public view virtual returns (uint256[] memory amounts) {\n        return SwapLibrary.getAmountsOut(factory, _amountIn, _path);\n    }\n\n    function getAmountsIn(\n        uint256 _amountOut,\n        address[] memory _path\n    ) public view virtual returns (uint256[] memory amounts) {\n        return SwapLibrary.getAmountsIn(factory, _amountOut, _path);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}