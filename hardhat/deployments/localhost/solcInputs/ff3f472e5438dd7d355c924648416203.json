{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20Burnable is Context, ERC20 {\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        _spendAllowance(account, _msgSender(), amount);\n        _burn(account, amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/bridge/destinationToken.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\n\ncontract WrappedStackDollars is ERC20, ERC20Burnable {\n    address bridge;\n\n    constructor(address _bridge) ERC20(\"WrappedStackDollars\", \"WSD\") {\n        bridge = _bridge;\n    }\n\n    modifier onlyBridge() {\n        require(bridge == msg.sender, \"WrappedToken: caller is not the bridge\");\n        _;\n    }\n\n    // @dev called from the bridge when tokens are locked on ETH side\n    function mint(address _recipient, uint _amount) public virtual onlyBridge {\n        _mint(_recipient, _amount);\n    }\n\n    // @dev called from the bridge when tokens are received\n    function burnFrom(\n        address _account,\n        uint _amount\n    ) public virtual override(ERC20Burnable) onlyBridge {\n        super.burnFrom(_account, _amount);\n    }\n}\n"
    },
    "contracts/bridge/originToken.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract StackDollars is ERC20 {\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint256 _initialSupply\n    ) ERC20(_name, _symbol) {\n        _mint(msg.sender, _initialSupply * (10 ** decimals()));\n    }\n}\n"
    },
    "contracts/bridge/WETH.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract WETH is ERC20, Ownable {\n    address public approved;\n\n    constructor(address bridge) ERC20(\"Wrapped Ether\", \"WETH\") {\n        approved = bridge;\n    }\n\n    modifier onlyApproved() {\n        require(msg.sender == approved, \"Not Athourized\");\n        _;\n    }\n\n    function mint(address _to, uint _amount) public onlyApproved {\n        _mint(_to, _amount);\n    }\n\n    function burn(address _to, uint _amount) public onlyApproved {\n        _burn(_to, _amount);\n    }\n\n    function setApproved(address _approved) public onlyOwner {\n        approved = _approved;\n    }\n}\n"
    },
    "contracts/core/LendingPool.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport \"hardhat/console.sol\";\n\nerror LendingPool__InvalidAmount();\nerror LendingPool__InvalidValue();\nerror LendingPool__InvalidUser();\n\ncontract LendingPool is ERC20 {\n    ERC20 immutable token;\n    address public immutable tokenAddress;\n    uint256 totalPoolSupply;\n    uint256 interestFactor;\n\n    // @dev the rate earned by the lender per second\n    uint256 lendRate = 100; // 100 / 10^18 = 0.0000000000000001% per second\n\n    // @dev the rate paid by the borrower per second\n    uint256 borrowRate = 130; // 130 / 10^18 = 0.00000000000000013% per second\n\n    uint256 periodBorrowed;\n\n    // @dev struct with amount and date of borrowing or lending\n    struct Amount {\n        uint256 amount;\n        uint256 start;\n    }\n\n    // @dev mapping of user address that has lended\n    mapping(address => Amount) private lendAmount;\n    // mapping of interest earned by the lender\n    mapping(address => uint256) private earnedInterest;\n\n    // @dev arrays to store the info about lenders & borrowers\n    mapping(address => bool) private lenders;\n    mapping(address => bool) private borrowers;\n\n    // @dev mapping to check if the address has borrowed any amount\n    mapping(address => Amount) private borrowAmount;\n    // @dev mapping of interest paid by the borrower\n    mapping(address => uint256) private paidInterest;\n\n    // Events\n    event Deposit(address indexed user, uint256 amount);\n    event Withdraw(address indexed user, uint256 amount);\n    event Borrow(address indexed user, uint256 amount);\n    event Repay(address indexed user, uint256 amount);\n\n    constructor(address _tokenAddress) ERC20(\"XToken\", \"XT\") {\n        token = ERC20(_tokenAddress);\n        tokenAddress = _tokenAddress;\n\n        uint256 tokenDecimals = token.decimals();\n        // Calculate the dynamic factor for interest rate\n        interestFactor = 10 ** tokenDecimals;\n    }\n\n    /**\n     * @dev - to liquidate the amount\n     * @param _liquidateAmount - amount to be liquidated\n     */\n\n    function liquidate(address _user, uint256 _liquidateAmount) public {\n        if (!borrowers[_user]) revert LendingPool__InvalidUser();\n\n        if (_liquidateAmount >= borrowAmount[_user].amount)\n            revert LendingPool__InvalidAmount();\n\n        token.transferFrom(_user, address(this), _liquidateAmount);\n\n        uint256 _reward = (_liquidateAmount * 3) / 100;\n        _updateBorrow(_user);\n        token.transfer(msg.sender, _reward);\n        borrowAmount[_user].amount -= _liquidateAmount + _reward;\n    }\n\n    /**\n     * @dev - to lend the amount by adding liquidity\n     * @param _amount - deposited amount\n     */\n    function deposit(uint256 _amount, address _user) external {\n        if (_amount == 0) revert LendingPool__InvalidAmount();\n\n        /// @dev transferring the tokens to the pool contract\n        token.transferFrom(_user, address(this), _amount);\n\n        /// @dev adding in lending and lenders array for tracking\n        lendAmount[_user].amount = _amount;\n        lendAmount[_user].start = block.timestamp;\n        lenders[_user] = true;\n\n        _mint(_user, _amount);\n\n        /// @dev updating the total pool supply\n        totalPoolSupply += _amount;\n        _updateLend(_user);\n        emit Deposit(_user, _amount);\n    }\n\n    /**\n     * @dev - to borrow the amount\n     * @param _amount - borrowed amount\n     */\n\n    function borrow(uint256 _amount, address _user) external {\n        if (_amount == 0) revert LendingPool__InvalidAmount();\n\n        if (_amount > totalPoolSupply / 10) revert LendingPool__InvalidValue();\n\n        /// @dev updating the total pool supply\n        borrowAmount[_user].amount = _amount;\n        borrowAmount[_user].start = block.timestamp;\n        totalPoolSupply -= _amount;\n\n        token.transfer(_user, _amount);\n\n        /// @dev tokenApproval to deduct the amount from the user\n        token.approve(address(this), _amount);\n\n        borrowers[_user] = true;\n        _updateBorrow(_user);\n        emit Borrow(_user, _amount);\n    }\n\n    /**\n     * @dev - to repay the amount\n     * @param _repayAmount - amount to be repaid\n     */\n    function repay(address _user, uint256 _repayAmount) external {\n        if (!borrowers[_user]) revert LendingPool__InvalidUser();\n\n        uint256 _amount = _calculateRepayAmount(_user, _repayAmount);\n\n        if (_amount == 0) revert LendingPool__InvalidAmount();\n\n        /// @dev transferring the tokens to the pool contract\n        token.transferFrom(_user, address(this), _amount);\n\n        /// @dev updating the total pool supply\n        borrowAmount[_user].amount -= _repayAmount;\n\n        if (borrowAmount[_user].amount == 0) {\n            borrowers[_user] = false;\n        }\n\n        totalPoolSupply += _repayAmount;\n        _updateBorrow(_user);\n        emit Repay(_user, _repayAmount);\n    }\n\n    /**\n     * @dev - to withdraw the amount\n     * @param _withdrawAmount - amount to be withdrawn\n     */\n    function withdraw(address _user, uint256 _withdrawAmount) external {\n        if (!lenders[_user]) revert LendingPool__InvalidUser();\n\n        /// @dev calculating the total amount with interest\n        uint256 _amount = _calculateWithdrawAmount(_user, _withdrawAmount);\n        console.log(_amount);\n        if (_amount == 0) revert LendingPool__InvalidAmount();\n\n        /// @dev delete the record from the lendAmount mapping\n        lendAmount[_user].amount -= _amount;\n\n        if (lendAmount[_user].amount == 0) {\n            lenders[_user] = false;\n        }\n\n        _burn(_user, _amount);\n\n        /// @dev updating the total supply before transferring the tokens\n        totalPoolSupply -= _withdrawAmount;\n\n        /// @dev transferring the tokens to the user\n        token.transfer(_user, _withdrawAmount);\n        _updateLend(_user);\n        emit Withdraw(_user, _withdrawAmount);\n    }\n\n    function getBorrowers(address _user) external view returns (uint256) {\n        return borrowAmount[_user].amount;\n    }\n\n    function getBorrowRate() external view returns (uint256) {\n        return borrowRate;\n    }\n\n    function getCurrentTotalSupply(\n        address _tokenAddress\n    ) external view returns (uint256) {\n        return token.balanceOf(_tokenAddress);\n    }\n\n    function _calculateRepayAmount(\n        address _user,\n        uint256 _repayAmount\n    ) internal view returns (uint256 _amount) {\n        /// @dev total amount to be repaid with interest\n        Amount storage amount_ = borrowAmount[_user];\n\n        require(_repayAmount <= amount_.amount, \"Invalid amount\");\n\n        uint256 _interest = (_repayAmount *\n            (((block.timestamp - amount_.start) * borrowRate) /\n                interestFactor)) / totalPoolSupply;\n\n        _amount = (_repayAmount + _interest);\n    }\n\n    function _calculateWithdrawAmount(\n        address _user,\n        uint256 _withdrawAmount\n    ) internal view returns (uint256 amount) {\n        Amount storage amount_ = lendAmount[_user];\n\n        require(_withdrawAmount <= amount_.amount, \"Invalid amount\");\n\n        uint256 elapsedTime = block.timestamp - amount_.start;\n\n        uint256 interestEarned = (_withdrawAmount *\n            elapsedTime *\n            lendRate *\n            interestFactor) / totalPoolSupply;\n\n        amount = (_withdrawAmount + interestEarned);\n    }\n\n    function _updateBorrow(\n        address _user\n    ) internal returns (uint256 _interestAmount) {\n        Amount storage amount_ = borrowAmount[_user];\n        _interestAmount =\n            (amount_.amount *\n                ((block.timestamp - amount_.start) *\n                    borrowRate *\n                    interestFactor)) /\n            totalPoolSupply;\n\n        paidInterest[_user] = _interestAmount;\n    }\n\n    function _updateLend(\n        address _user\n    ) internal returns (uint256 _interestAmount) {\n        Amount storage amount_ = lendAmount[_user];\n\n        _interestAmount =\n            (amount_.amount *\n                ((block.timestamp - amount_.start) *\n                    lendRate *\n                    interestFactor)) /\n            totalPoolSupply;\n\n        earnedInterest[_user] = _interestAmount;\n    }\n}\n"
    },
    "contracts/core/StakingPool.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\nimport \"../interfaces/IERC20.sol\";\n\ncontract StakingPool {\n    IERC20 public rewardToken;\n    IERC20 public stakingToken;\n    uint256 private _totalSupply;\n    uint256 public rewardRate;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n    uint256 public decimalFactor;\n\n    mapping(address => uint256) public rewards;\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public staked;\n\n    /// @dev - modifier that will calculate the amount of rewards earned and add it to the rewards mapping\n    modifier updateReward(address _account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = block.timestamp;\n        rewards[_account] = _rewardEarned(_account);\n        userRewardPerTokenPaid[_account] = rewardPerTokenStored;\n        _;\n    }\n\n    constructor(address _stakingToken, address _rewardToken) {\n        stakingToken = IERC20(_stakingToken);\n        rewardToken = IERC20(_rewardToken);\n\n        uint256 rewardTokenDecimals = rewardToken.decimals();\n        decimalFactor = 10 ** rewardTokenDecimals;\n    }\n\n    /// @dev - to stake tokens into the pool\n    /// @param _amount - the amount of tokens to stake\n    function stakeToken(\n        uint256 _amount,\n        address _user\n    ) external updateReward(_user) {\n        require(_amount > 0, \"Cannot stake 0 tokens\");\n        _totalSupply += _amount;\n        staked[_user] += _amount;\n        stakingToken.transferFrom(msg.sender, address(this), _amount);\n    }\n\n    /// @dev - to withdraw tokens from the pool\n    /// @param _amount - the amount of tokens to withdraw\n    function withdrawToken(\n        uint256 _amount,\n        address _user\n    ) external updateReward(_user) {\n        require(_amount > 0, \"Cannot withdraw 0 tokens\");\n        _totalSupply -= _amount;\n        staked[_user] -= _amount;\n        stakingToken.transfer(msg.sender, _amount);\n    }\n\n    /// @dev - To calculuate the amount of rewards per token staked\n    /// @return uint256 - The amount of rewards per token staked\n    function rewardPerToken() public view returns (uint256) {\n        if (_totalSupply == 0) {\n            return rewardPerTokenStored;\n        }\n\n        return\n            rewardPerTokenStored +\n            (((block.timestamp - lastUpdateTime) * rewardRate * decimalFactor) /\n                _totalSupply);\n    }\n\n    /**\n     * @dev - to calculate the earned rewards for a user based on the amount of tokens staked\n     * @param _account - the address of the user\n     * @return uint256 - the amount of rewards earned\n     */\n\n    function _rewardEarned(address _account) internal view returns (uint256) {\n        return\n            ((staked[_account] *\n                (rewardPerToken() - userRewardPerTokenPaid[_account])) /\n                decimalFactor) + rewards[_account];\n    }\n}\n"
    },
    "contracts/core/SwapPairTokens.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\nimport \"../libraries/Math.sol\";\nimport \"../libraries/UQ112x112.sol\";\nimport \"../interfaces/IERC20.sol\";\nimport \"../interfaces/ISwapFactory.sol\";\nimport \"./SwapTokens.sol\";\n\ncontract SwapPairTokens is SwapTokens {\n    using SafeMath for uint256;\n    using UQ112x112 for uint224;\n\n    uint256 public constant MINIMUM_LIQUIDITY = 10 ** 3;\n    bytes4 private constant SELECTOR =\n        bytes4(keccak256(bytes(\"transfer(address,uint256)\")));\n\n    address public factory;\n    address public token0;\n    address public token1;\n\n    uint112 private reserve0; // uses single storage slot, accessible via getReserves\n    uint112 private reserve1; // uses single storage slot, accessible via getReserves\n    uint32 private blockTimestampLast; // uses single storage slot, accessible via getReserves\n\n    uint256 public price0CumulativeLast;\n    uint256 public price1CumulativeLast;\n    uint256 public kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity event\n\n    uint256 private unlocked = 1;\n\n    modifier lock() {\n        require(unlocked == 1, \"SwapPairTokens: LOCKED\");\n        unlocked = 0;\n        _;\n        unlocked = 1;\n    }\n\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n    event Burn(\n        address indexed sender,\n        uint256 amount0,\n        uint256 amount1,\n        address indexed to\n    );\n    event Swap(\n        address indexed sender,\n        uint256 amount0In,\n        uint256 amount1In,\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address indexed to\n    );\n    event Sync(uint256 reserve0, uint256 reserve1);\n\n    constructor() {\n        factory = msg.sender;\n    }\n\n    function getReserves()\n        public\n        view\n        returns (\n            uint112 _reserve0,\n            uint112 _reserve1,\n            uint32 _blockTimestampLast\n        )\n    {\n        _reserve0 = reserve0;\n        _reserve1 = reserve1;\n        _blockTimestampLast = blockTimestampLast;\n    }\n\n    // called once by the factory at time of deployment\n    function initialize(address _token0, address _token1) external {\n        require(msg.sender == factory, \"SwapPairTokens: FORBIDDEN\"); // sufficient check\n        token0 = _token0;\n        token1 = _token1;\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function burn(\n        address _to\n    ) external lock returns (uint256 _amount0, uint256 _amount1) {\n        (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\n        address _token0 = token0; // gas savings\n        address _token1 = token1; // gas savings\n        uint256 balance0 = IERC20(_token0).balanceOf(address(this));\n        uint256 balance1 = IERC20(_token1).balanceOf(address(this));\n        uint256 liquidity = balanceOf[address(this)];\n\n        bool feeOn = _collectFee(_reserve0, _reserve1);\n        uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\n        _amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution\n        _amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution\n        require(\n            _amount0 > 0 && _amount1 > 0,\n            \"SwapPairTokens: INSUFFICIENT_LIQUIDITY_BURNED\"\n        );\n        _burn(address(this), liquidity);\n        _safeTransfer(_token0, _to, _amount0);\n        _safeTransfer(_token1, _to, _amount1);\n        balance0 = IERC20(_token0).balanceOf(address(this));\n        balance1 = IERC20(_token1).balanceOf(address(this));\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        if (feeOn) kLast = uint256(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date\n        emit Burn(msg.sender, _amount0, _amount1, _to);\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function mint(address _to) external lock returns (uint256 liquidity) {\n        (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\n        uint256 balance0 = IERC20(token0).balanceOf(address(this));\n        uint256 balance1 = IERC20(token1).balanceOf(address(this));\n        uint256 amount0 = balance0.sub(_reserve0);\n        uint256 amount1 = balance1.sub(_reserve1);\n\n        bool feeOn = _collectFee(_reserve0, _reserve1);\n        uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\n        if (_totalSupply == 0) {\n            liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);\n            _mint(address(0), MINIMUM_LIQUIDITY);\n            // permanently lock the first MINIMUM_LIQUIDITY tokens\n        } else {\n            liquidity = Math.min(\n                balance0.mul(_totalSupply) / _reserve0,\n                balance1.mul(_totalSupply) / _reserve1\n            );\n        }\n        require(liquidity > 0, \"SwapPairTokens: INSUFFICIENT_LIQUIDITY_MINTED\");\n        _mint(_to, liquidity);\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        if (feeOn) kLast = uint256(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date\n        emit Mint(msg.sender, amount0, amount1);\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function swap(\n        uint256 _amount0Out,\n        uint256 _amount1Out,\n        address _to,\n        bytes calldata _data\n    ) external lock {\n        require(\n            _amount0Out > 0 || _amount1Out > 0,\n            \"SwapPairTokens: INSUFFICIENT_OUTPUT_AMOUNT\"\n        );\n        (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\n        require(\n            _amount0Out < _reserve0 && _amount1Out < _reserve1,\n            \"SwapPairTokens: INSUFFICIENT_LIQUIDITY\"\n        );\n\n        uint256 balance0;\n        uint256 balance1;\n        {\n            // scope for _token{0,1}, avoids stack too deep errors\n            address _token0 = token0;\n            address _token1 = token1;\n            require(\n                _to != _token0 && _to != _token1,\n                \"SwapPairTokens: INVALID_TO\"\n            );\n            if (_amount0Out > 0) _safeTransfer(_token0, _to, _amount0Out); // optimistically transfer tokens\n            if (_amount1Out > 0) _safeTransfer(_token1, _to, _amount1Out); // optimistically transfer tokens\n            balance0 = IERC20(_token0).balanceOf(address(this));\n            balance1 = IERC20(_token1).balanceOf(address(this));\n        }\n        uint256 amount0In = balance0 > _reserve0 - _amount0Out\n            ? balance0 - (_reserve0 - _amount0Out)\n            : 0;\n        uint256 amount1In = balance1 > _reserve1 - _amount1Out\n            ? balance1 - (_reserve1 - _amount1Out)\n            : 0;\n        require(\n            amount0In > 0 || amount1In > 0,\n            \"SwapPairTokens: INSUFFICIENT_INPUT_AMOUNT\"\n        );\n        {\n            // scope for reserve{0,1}Adjusted, avoids stack too deep errors\n            uint256 balance0Adjusted = (\n                balance0.mul(1000).sub(amount0In.mul(3))\n            );\n            uint256 balance1Adjusted = (\n                balance1.mul(1000).sub(amount1In.mul(3))\n            );\n            require(\n                balance0Adjusted.mul(balance1Adjusted) >=\n                    uint256(_reserve0).mul(_reserve1).mul(1000 ** 2),\n                \"SwapPairTokens: K\"\n            );\n        }\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n\n        emit Swap(\n            msg.sender,\n            amount0In,\n            amount1In,\n            _amount0Out,\n            _amount1Out,\n            _to\n        );\n    }\n\n    // force balances to match reserves\n    function skim(address _to) external lock {\n        address _token0 = token0; // gas savings\n        address _token1 = token1; // gas savings\n        _safeTransfer(\n            _token0,\n            _to,\n            IERC20(_token0).balanceOf(address(this)).sub(reserve0)\n        );\n        _safeTransfer(\n            _token1,\n            _to,\n            IERC20(_token1).balanceOf(address(this)).sub(reserve1)\n        );\n    }\n\n    // force reserves to match balances\n    function sync() external lock {\n        _update(\n            IERC20(token0).balanceOf(address(this)),\n            IERC20(token1).balanceOf(address(this)),\n            reserve0,\n            reserve1\n        );\n    }\n\n    // update reserves and, on the first call per block, price accumulators\n    function _update(\n        uint256 balance0,\n        uint256 balance1,\n        uint112 _reserve0,\n        uint112 _reserve1\n    ) private {\n        require(\n            balance0 <= (2 ** 122 - 1) && balance1 <= (2 ** 122 - 1),\n            \"SwapPairTokens: OVERFLOW\"\n        );\n        uint32 blockTimestamp = uint32(block.timestamp % 2 ** 32);\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\n        if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {\n            // * never overflows, and + overflow is desired\n            price0CumulativeLast +=\n                uint256(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) *\n                timeElapsed;\n            price1CumulativeLast +=\n                uint256(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) *\n                timeElapsed;\n        }\n        reserve0 = uint112(balance0);\n        reserve1 = uint112(balance1);\n        blockTimestampLast = blockTimestamp;\n        emit Sync(reserve0, reserve1);\n    }\n\n    // if fee is on, mint liquidity equivalent to 1/6th of the growth in sqrt(k)\n    function _collectFee(\n        uint112 _reserve0,\n        uint112 _reserve1\n    ) private returns (bool feeOn) {\n        address feeTo = ISwapFactory(factory).feeTo();\n        feeOn = feeTo != address(0);\n        uint256 _kLast = kLast; // gas savings\n        if (feeOn) {\n            if (_kLast != 0) {\n                uint256 rootK = Math.sqrt(uint256(_reserve0).mul(_reserve1));\n                uint256 rootKLast = Math.sqrt(_kLast);\n                if (rootK > rootKLast) {\n                    uint256 numerator = totalSupply.mul(rootK.sub(rootKLast));\n                    uint256 denominator = rootK.mul(5).add(rootKLast);\n                    uint256 liquidity = numerator / denominator;\n                    if (liquidity > 0) _mint(feeTo, liquidity);\n                }\n            }\n        } else if (_kLast != 0) {\n            kLast = 0;\n        }\n    }\n\n    function _safeTransfer(\n        address _token,\n        address _to,\n        uint256 _value\n    ) private {\n        (bool success, bytes memory data) = _token.call(\n            abi.encodeWithSelector(SELECTOR, _to, _value)\n        );\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"SwapPairTokens: TRANSFER_FAILED\"\n        );\n    }\n}\n"
    },
    "contracts/core/SwapPairTokens2.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\nimport \"./SwapTokens.sol\";\nimport \"../interfaces/IERC20.sol\";\n\ncontract SwapPairTokens2 is SwapTokens {\n    IERC20 public immutable token0;\n    IERC20 public immutable token1;\n\n    // tracks the internal balances of the pool\n    uint256 public reserve0;\n    uint256 public reserve1;\n\n    uint256 public price0CumulativeLast;\n    uint256 public price1CumulativeLast;\n    uint256 public kLast;\n\n    constructor(address _token0, address _token1) {\n        token0 = IERC20(_token0);\n        token1 = IERC20(_token1);\n    }\n\n    // swap tokens\n    function swap(\n        address _tokenIn,\n        uint256 _amountIn\n    ) external returns (uint256 amountOut) {\n        require(\n            _tokenIn == address(token0) || _tokenIn == address(token1),\n            \"INVALID TOKEN\"\n        );\n        require(_amountIn > 0, \"INSUFFICIENT INPUT AMOUNT\");\n\n        bool isToken0 = _tokenIn == address(token0);\n\n        // assigning the tokens to the correct variables\n        (\n            IERC20 tokenIn,\n            IERC20 tokenOut,\n            uint256 reserveIn,\n            uint256 reserveOut\n        ) = isToken0\n                ? (token0, token1, reserve0, reserve1)\n                : (token1, token0, reserve1, reserve0);\n\n        // transferring the tokens from the sender to the contract\n        tokenIn.transferFrom(msg.sender, address(this), _amountIn);\n\n        // fee calculation of 0.3%\n        uint256 _amountInWithFee = (_amountIn * 997) / 1000;\n\n        /**\n         * ydx / (x + dx) = dy\n         * y = reserveOut, dy = _amountOut\n         * x = reserveIn, dx = _amountInWithFee\n         */\n        amountOut =\n            (reserveOut * _amountInWithFee) /\n            (reserveIn + _amountInWithFee);\n\n        // tokenOut transfer to the sender\n        tokenOut.transfer(msg.sender, amountOut);\n\n        // updating the reserves\n        _update(\n            token0.balanceOf(address(this)),\n            token1.balanceOf(address(this))\n        );\n    }\n\n    function addLiquidity(\n        uint256 _amount0,\n        uint256 _amount1\n    ) external returns (uint256 shares) {\n        token0.transferFrom(msg.sender, address(this), _amount0);\n        token1.transferFrom(msg.sender, address(this), _amount1);\n\n        if (reserve0 > 0 || reserve1 > 0) {\n            require(\n                reserve0 * _amount1 == reserve1 * _amount0,\n                \"x / y != dx / dy\"\n            );\n        }\n\n        if (totalSupply == 0) {\n            shares = _sqrt(_amount0 * _amount1);\n        } else {\n            // whichever value is the minimum will be the shares of (dx * T / x) or (dy * T / y\n            shares = _min(\n                (_amount0 * totalSupply) / reserve0,\n                (_amount1 * totalSupply) / reserve1\n            );\n        }\n    }\n\n    function removeLiquidity(\n        uint256 _shares\n    ) external returns (uint256 amount0, uint256 amount1) {\n        uint256 bal0 = token0.balanceOf(address(this));\n        uint256 bal1 = token1.balanceOf(address(this));\n\n        // calculating the amount of tokens to be transferred\n        amount0 = (bal0 * _shares) / totalSupply;\n        amount1 = (bal1 * _shares) / totalSupply;\n        require(amount0 > 0 && amount1 > 0, \"INSUFFICIENT LIQUIDITY\");\n\n        // burning the shares and updating the reserves\n        _burn(msg.sender, _shares);\n        _update(bal0 - amount0, bal1 - amount1);\n\n        // transferring the tokens to the sender\n        token0.transfer(msg.sender, amount0);\n        token1.transfer(msg.sender, amount1);\n    }\n\n    // to update the reserver of the pool\n    function _update(uint256 _reserve0, uint256 _reserve1) private {\n        require(\n            _reserve0 <= type(uint112).max && _reserve1 <= type(uint112).max,\n            \"OVERFLOW\"\n        );\n        reserve0 = _reserve0;\n        reserve1 = _reserve1;\n    }\n\n    // to calculate the square root of the number\n    function _sqrt(uint256 y) private pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n\n    // to find the minimum of the two numbers\n    function _min(uint256 x, uint256 y) private pure returns (uint256) {\n        return x = x <= y ? x : y;\n    }\n}\n"
    },
    "contracts/core/SwapTokens.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\nimport \"../libraries/safeMath.sol\";\n\ncontract SwapTokens {\n    using SafeMath for uint256;\n\n    string public constant name = \"SwapTokens\";\n    string public constant symbol = \"SWT\";\n    uint8 public constant decimals = 18;\n\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    mapping(address => uint256) public nonces;\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function approve(address _spender, uint256 _value) external returns (bool) {\n        _approve(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function transfer(address _to, uint256 _value) external returns (bool) {\n        _transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 value\n    ) external returns (bool) {\n        if (allowance[_from][msg.sender] != 2 ** 112 - 1) {\n            allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(\n                value\n            );\n        }\n        _transfer(_from, _to, value);\n        return true;\n    }\n\n    function _transfer(address _from, address _to, uint256 value) private {\n        balanceOf[_from] = balanceOf[_from].sub(value);\n        balanceOf[_to] = balanceOf[_to].add(value);\n        emit Transfer(_from, _to, value);\n    }\n\n    function _approve(\n        address _owner,\n        address _spender,\n        uint256 _value\n    ) private {\n        require(_spender != address(0), \"Spender cannot be 0 address\");\n        require(_owner != address(0), \"Owner cannot be 0 address\");\n\n        allowance[_owner][_spender] = _value;\n        emit Approval(_owner, _spender, _value);\n    }\n\n    function _mint(address _to, uint256 _value) internal {\n        totalSupply = totalSupply.add(_value);\n        balanceOf[_to] = balanceOf[_to].add(_value);\n        emit Transfer(address(0), _to, _value);\n    }\n\n    function _burn(address _from, uint256 _value) internal {\n        balanceOf[_from] = balanceOf[_from].sub(_value);\n        totalSupply = totalSupply.sub(_value);\n        emit Transfer(_from, address(0), _value);\n    }\n}\n"
    },
    "contracts/factory/LendingPoolFactory.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\nimport \"../core/LendingPool.sol\";\n\ncontract LendingPoolFactory {\n    address public feeProvider;\n    address public feeToSetter;\n\n    mapping(address => address) public getLendingPool;\n    address[] public allLendingPools;\n\n    event LendingPoolCreated(\n        address indexed sender,\n        address indexed pool,\n        uint256 timestamp\n    );\n\n    constructor(address _feeToSetter) {\n        feeToSetter = _feeToSetter;\n    }\n\n    function allPoolsLength() external view returns (uint256) {\n        return allLendingPools.length;\n    }\n\n    function createPool(address _token) external returns (address) {\n        require(_token != address(0), \"INVALID_TOKEN_ADDRESS\");\n        require(getLendingPool[_token] == address(0), \"LENDING_POOL_EXISTS\");\n\n        LendingPool pool = new LendingPool(_token);\n\n        getLendingPool[_token] = address(pool);\n        allLendingPools.push(address(pool));\n\n        emit LendingPoolCreated(msg.sender, address(pool), block.timestamp);\n        return address(pool);\n    }\n\n    function setFeeTo(address _feeTo) external {\n        require(msg.sender == feeToSetter, \"UNAUTHORIZED\");\n        feeToSetter = _feeTo;\n    }\n\n    function setFeeToSetter(address _feeToSetter) external {\n        require(msg.sender == feeToSetter, \"UNAUTHORIZED\");\n        feeToSetter = _feeToSetter;\n    }\n}\n"
    },
    "contracts/factory/StakingPoolFactory.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\nimport \"../core/StakingPool.sol\";\n\ncontract StakingPoolFactory {\n    address public feeTo;\n    address public feeToSetter;\n    address[] public allPools;\n\n    mapping(address => mapping(address => address)) public getPool;\n\n    event PoolCreated(address indexed token, address pool, uint256 timestamp);\n\n    constructor(address _feeToSetter) {\n        feeToSetter = _feeToSetter;\n    }\n\n    function allPoolsLength() external view returns (uint256) {\n        return allPools.length;\n    }\n\n    /**\n     * @dev - Creates a new pool for the given token pair\n     * @dev - assembly is used to create the pool contract with the CREATE2 opcode\n     * @param _stakingToken - the token that will be staked\n     * @param _rewardToken  - the token that will be rewarded\n     * @return pool - the address of the pool that was created\n     *\n     */\n\n    function createPool(\n        address _stakingToken,\n        address _rewardToken\n    ) external returns (address pool) {\n        require(\n            getPool[_stakingToken][_rewardToken] == address(0),\n            \"StakingPoolFactory::createPool: Pool already exists\"\n        );\n        bytes memory bytecode = type(StakingPool).creationCode;\n        bytes32 salt = keccak256(abi.encodePacked(_stakingToken, _rewardToken));\n        assembly {\n            pool := create2(0, add(bytecode, 32), mload(bytecode), salt)\n        }\n        StakingPool _pool = new StakingPool(_stakingToken, _rewardToken);\n\n        getPool[_stakingToken][_rewardToken] = address(_pool);\n        allPools.push(address(_pool));\n        emit PoolCreated(_stakingToken, address(_pool), block.timestamp);\n\n        return address(_pool);\n    }\n\n    function setFeeTo(address _feeTo) external {\n        require(\n            msg.sender == feeToSetter,\n            \"StakingPoolFactory::setFeeTo: FORBIDDEN\"\n        );\n        feeTo = _feeTo;\n    }\n\n    function setFeeToSetter(address _feeToSetter) external {\n        require(\n            msg.sender == feeToSetter,\n            \"StakingPoolFactory::setFeeToSetter: FORBIDDEN\"\n        );\n        feeToSetter = _feeToSetter;\n    }\n}\n"
    },
    "contracts/factory/SwapPairTokensFactory.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\nimport \"../core/SwapPairTokens.sol\";\n\ncontract SwapPairTokensFactory {\n    address public feeTo;\n    address public feeToSetter;\n\n    mapping(address => mapping(address => address)) public getPair;\n    address[] public allPairs;\n\n    event PairCreated(\n        address indexed token0,\n        address indexed token1,\n        address pair,\n        uint256\n    );\n\n    constructor(address _feeToSetter) {\n        feeToSetter = _feeToSetter;\n    }\n\n    function allPairsLength() external view returns (uint256) {\n        return allPairs.length;\n    }\n\n    function createPair(\n        address tokenA,\n        address tokenB\n    ) external returns (address pair) {\n        require(\n            tokenA != tokenB,\n            \"SwapPairTokensFactory::createPair: IDENTICAL_ADDRESSES\"\n        );\n        (address token0, address token1) = tokenA < tokenB\n            ? (tokenA, tokenB)\n            : (tokenB, tokenA);\n        require(\n            tokenA != address(0),\n            \"SwapPairTokensFactory::createPair: ZERO_ADDRESS\"\n        );\n        require(\n            getPair[token0][token1] == address(0),\n            \"SwapPairTokensFactory::createPair: PAIR_EXISTS\"\n        ); // single check is sufficient\n        bytes memory bytecode = type(SwapPairTokens).creationCode;\n        bytes32 salt = keccak256(abi.encodePacked(token0, token1));\n        assembly {\n            pair := create2(0, add(bytecode, 32), mload(bytecode), salt)\n        }\n        SwapPairTokens(pair).initialize(token0, token1);\n\n        getPair[token0][token1] = pair;\n        getPair[token1][token0] = pair; // populate mapping in the reverse direction\n        allPairs.push(pair);\n        emit PairCreated(token0, token1, pair, allPairs.length);\n    }\n\n    function setFeeTo(address _feeTo) external {\n        require(\n            msg.sender == feeToSetter,\n            \"SwapPairTokensFactory::setFeeTo: FORBIDDEN\"\n        );\n        feeTo = _feeTo;\n    }\n\n    function setFeeToSetter(address _feeToSetter) external {\n        require(\n            msg.sender == feeToSetter,\n            \"SwapPairTokensFactory::setFeeToSetter: FORBIDDEN\"\n        );\n        feeToSetter = _feeToSetter;\n    }\n}\n"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\ninterface IERC20 {\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function totalSupply() external view returns (uint256);\n\n    function decimals() external view returns (uint256);\n\n    function balanceOf(address _owner) external view returns (uint256);\n\n    function allowance(\n        address _owner,\n        address _spender\n    ) external view returns (uint256);\n\n    function approve(address _spender, uint256 _value) external returns (bool);\n\n    function transfer(address _to, uint256 _value) external returns (bool);\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) external returns (bool);\n}\n"
    },
    "contracts/interfaces/IERC20V2.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\ninterface IERC20V2 {\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address _owner) external view returns (uint256);\n\n    function allowance(\n        address _owner,\n        address _spender\n    ) external view returns (uint256);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function PERMIT_TYPEHASH() external view returns (bytes32);\n\n    function nonces(address owner) external view returns (uint256);\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"
    },
    "contracts/interfaces/ILendingPool.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\ninterface ILendingPool {\n    struct Amount {\n        uint256 amount;\n        uint256 start;\n    }\n\n    function lendAmount(address _user) external view returns (Amount memory);\n\n    function earnedInterest(address _user) external view returns (uint256);\n\n    function borrowAmount(address _user) external view returns (Amount memory);\n\n    function payInterest(address user) external view returns (uint256);\n\n    function lenders(address _user) external view returns (bool);\n\n    function borrowers(address _user) external view returns (bool);\n\n    function deposit(uint256 _amount, address _user) external;\n\n    function borrow(uint256 _amount, address _user) external;\n\n    function repay(address _user, uint256 _amount) external;\n\n    function withdraw(address _user, uint256 _amount) external;\n\n    function liquidate(address _user, uint256 _amount) external;\n\n    function calculateRepayAmount(\n        address _user,\n        uint256 _amount\n    ) external view returns (uint256);\n\n    function calculateWithdrawAmount(\n        address _user,\n        uint256 _amount\n    ) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/ILendingPoolFactory.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\ninterface ILendingPoolFactory {\n    function getPool(address _token) external view returns (address);\n\n    function allPools() external view returns (address[] memory);\n\n    function allPoolsLength() external view returns (uint256);\n\n    function createPool(address _token) external returns (address);\n}\n"
    },
    "contracts/interfaces/IRToken.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\ninterface IRToken {\n    event Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _value\n    );\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n\n    event Deposit(address indexed _owner, uint256 _value);\n\n    event Withdraw(address indexed _owner, uint256 _value);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint256);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address _owner) external view returns (uint256);\n\n    function allowance(\n        address _owner,\n        address _spender\n    ) external view returns (uint256);\n\n    function approve(address _spender, uint256 _value) external returns (bool);\n\n    function transfer(address _to, uint256 _value) external returns (bool);\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) external returns (bool);\n\n    function deposit() external payable;\n\n    function withdraw(uint256 _value) external;\n}\n"
    },
    "contracts/interfaces/IStakingPool.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\ninterface IStakingPool {\n    function staked(address _user) external view returns (uint256);\n\n    function earned(address _user) external view returns (uint256);\n\n    function stake(uint256 _amount, address _account) external;\n\n    function withdraw(uint256 _amount, address _account) external;\n\n    function rewards(address _user) external view returns (uint256);\n\n    function totalSupply() external view returns (uint256);\n\n    function rewardPerToken() external view returns (uint256);\n\n    function redeemReward(address _user) external;\n}\n"
    },
    "contracts/interfaces/IStakingPoolFactory.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\ninterface IStakingPoolFactory {\n    function getPool(address _token) external view returns (address);\n\n    function allPools() external view returns (address[] memory);\n\n    function allPoolsLength() external view returns (uint256);\n\n    function createPool(\n        address _token0,\n        address _token1\n    ) external returns (address);\n}\n"
    },
    "contracts/interfaces/ISwapFactory.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\ninterface ISwapFactory {\n    event PairCreated(\n        address indexed token0,\n        address indexed token1,\n        address pair,\n        uint256\n    );\n\n    function feeTo() external view returns (address);\n\n    function feeToSetter() external view returns (address);\n\n    function getPair(\n        address _tokenA,\n        address _tokenB\n    ) external view returns (address pair);\n\n    function allPairs(uint256) external view returns (address pair);\n\n    function allPairsLength() external view returns (uint256);\n\n    function createPair(\n        address _tokenA,\n        address _tokenB\n    ) external returns (address pair);\n\n    function setFeeTo(address) external;\n\n    function setFeeToSetter(address) external;\n}\n"
    },
    "contracts/interfaces/ISwapPairTokens.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\ninterface ISwapPairTokens {\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n    event Burn(\n        address indexed sender,\n        uint256 amount0,\n        uint256 amount1,\n        address indexed to\n    );\n    event Swap(\n        address indexed sender,\n        uint256 amount0In,\n        uint256 amount1In,\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address indexed to\n    );\n\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint256);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address _owner) external view returns (uint256);\n\n    function allowance(\n        address _owner,\n        address _spender\n    ) external view returns (uint256);\n\n    function approve(address _spender, uint256 _value) external returns (bool);\n\n    function transfer(address _to, uint256 _value) external returns (bool);\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) external returns (bool);\n\n    function permit(\n        address _owner,\n        address _spender,\n        uint256 _value,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external;\n\n    function MINIMUM_LIQUIDITY() external view returns (uint256);\n\n    function factory() external view returns (address);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function getReserves()\n        external\n        view\n        returns (\n            uint112 _reserve0,\n            uint112 _reserve1,\n            uint32 _blockTimestampLast\n        );\n\n    function price0CumulativeLast() external view returns (uint256);\n\n    function price1CumulativeLast() external view returns (uint256);\n\n    function kLast() external view returns (uint256);\n\n    function mint(address _to) external returns (uint256 liquidity);\n\n    function burn(\n        address _to\n    ) external returns (uint256 amount0, uint256 amount1);\n\n    function swap(\n        uint256 _amount0Out,\n        uint256 _amount1Out,\n        address _to,\n        bytes calldata _data\n    ) external;\n\n    function skim(address _to) external;\n\n    function sync() external;\n\n    function initialize(address _token0, address _token1) external;\n}\n"
    },
    "contracts/interfaces/ISwapRouter.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\ninterface ISwapRouter {\n    function factory() external view returns (address);\n\n    function WETH() external view returns (address);\n\n    function addLiquidity(\n        address _tokenA,\n        address _tokenB,\n        uint256 _amountADesired,\n        uint256 _amountBDesired,\n        uint256 _amountAMin,\n        uint256 _amountBMin,\n        address _to,\n        uint256 _deadline\n    ) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\n\n    function addLiquidityETH(\n        address _token,\n        uint256 _amountTokenDesired,\n        uint256 _amountTokenMin,\n        uint256 _amountETHMin,\n        address _to,\n        uint256 _deadline\n    )\n        external\n        payable\n        returns (uint256 amountToken, uint256 amountETH, uint256 liquidity);\n\n    function removeLiquidity(\n        address _tokenA,\n        address _tokenB,\n        uint256 _liquidity,\n        uint256 _amountAMin,\n        uint256 _amountBMin,\n        address _to,\n        uint256 _deadline\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function removeLiquidityETH(\n        address _token,\n        uint256 _liquidity,\n        uint256 _amountTokenMin,\n        uint256 _amountETHMin,\n        address _to,\n        uint256 _deadline\n    ) external returns (uint256 amountToken, uint256 amountETH);\n\n    function removeLiquidityWithPermit(\n        address _tokenA,\n        address _tokenB,\n        uint256 _liquidity,\n        uint256 _amountAMin,\n        uint256 _amountBMin,\n        address _to,\n        uint256 _deadline,\n        bool _approveMax,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function removeLiquidityETHWithPermit(\n        address _token,\n        uint256 _liquidity,\n        uint256 _amountTokenMin,\n        uint256 _amountETHMin,\n        address _to,\n        uint256 _deadline,\n        bool _approveMax,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external returns (uint256 amountToken, uint256 amountETH);\n\n    function swapExactTokensForTokens(\n        uint256 _amountIn,\n        uint256 _amountOutMin,\n        address[] calldata _path,\n        address _to,\n        uint256 _deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapTokensForExactTokens(\n        uint256 _amountOut,\n        uint256 _amountInMax,\n        address[] calldata _path,\n        address _to,\n        uint256 _deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactETHForTokens(\n        uint256 _amountOutMin,\n        address[] calldata _path,\n        address _to,\n        uint256 _deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function swapTokensForExactETH(\n        uint256 _amountOut,\n        uint256 _amountInMax,\n        address[] calldata _path,\n        address _to,\n        uint256 _deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactTokensForETH(\n        uint256 _amonutIn,\n        uint256 _amountOutMin,\n        address[] calldata _path,\n        address _to,\n        uint256 _deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapETHForExactTokens(\n        uint256 _amountOut,\n        address[] calldata _path,\n        address _to,\n        uint256 _deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function quote(\n        uint256 _amountA,\n        uint256 _reserveA,\n        uint256 _reserveB\n    ) external pure returns (uint256 amountB);\n\n    function getAmountOut(\n        uint256 _amountIn,\n        uint256 _reserveIn,\n        uint256 _reserveOut\n    ) external pure returns (uint256 amountOut);\n\n    function getAmountIn(\n        uint256 _amountOut,\n        uint256 _reserveIn,\n        uint256 _reserveOut\n    ) external pure returns (uint256 amountIn);\n\n    function getAmountsOut(\n        uint256 _amountIn,\n        address[] calldata _path\n    ) external view returns (uint256[] memory amounts);\n\n    function getAmountsIn(\n        uint256 _amountOut,\n        address[] calldata _path\n    ) external view returns (uint256[] memory amounts);\n\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address _token,\n        uint256 _liquidity,\n        uint256 _amountTokenMin,\n        uint256 _amountETHMin,\n        address _to,\n        uint256 _deadline\n    ) external returns (uint256 amountETH);\n\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address _token,\n        uint256 _liquidity,\n        uint256 _amountTokenMin,\n        uint256 _amountETHMin,\n        address _to,\n        uint256 _deadline,\n        bool _approveMax,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external returns (uint256 amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint256 _amountIn,\n        uint256 _amountOutMin,\n        address[] calldata _path,\n        address _to,\n        uint256 _deadline\n    ) external;\n\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable;\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n}\n"
    },
    "contracts/interfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\ninterface IWETH {\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Deposit(address indexed account, uint256 amount);\n    event Withdrawal(address indexed account, uint256 amount);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint256);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address _owner) external view returns (uint256);\n\n    function allowance(\n        address _owner,\n        address _spender\n    ) external view returns (uint256);\n\n    function approve(address _spender, uint256 _value) external returns (bool);\n\n    function transfer(address _to, uint256 _value) external returns (bool);\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) external returns (bool);\n\n    function deposit() external payable;\n\n    function withdraw(uint256 _amount) external;\n}\n"
    },
    "contracts/libraries/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n// a library for performing various math operations\n\nlibrary Math {\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x < y ? x : y;\n    }\n\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n}\n"
    },
    "contracts/libraries/safeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\n\nlibrary SafeMath {\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\n    }\n\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\n    }\n\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\n    }\n}\n"
    },
    "contracts/libraries/SwapLibrary.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\nimport \"../interfaces/ISwapPairTokens.sol\";\nimport \"../interfaces/ISwapFactory.sol\";\nimport \"../libraries/safeMath.sol\";\n\nlibrary SwapLibrary {\n    using SafeMath for uint256;\n\n    function sortTokens(\n        address _tokenA,\n        address _tokenB\n    ) internal pure returns (address token0, address token1) {\n        require(_tokenA != _tokenB, \"SwapLibrary: IDENTICAL_ADDRESSES\");\n        (token0, token1) = _tokenA < _tokenB\n            ? (_tokenA, _tokenB)\n            : (_tokenB, _tokenA);\n        require(token0 != address(0), \"SwapLibrary: ZERO_ADDRESS\");\n    }\n\n    // calculates the CREATE2 address for a pair without making any external calls\n    function pairFor(\n        address _factory,\n        address _tokenA,\n        address _tokenB\n    ) internal view returns (address pair) {\n        (address token0, address token1) = sortTokens(_tokenA, _tokenB);\n        pair = ISwapFactory(_factory).getPair(token0, token1);\n    }\n\n    // fetches and sorts the reserves for a pair\n    function getReserves(\n        address _factory,\n        address _tokenA,\n        address _tokenB\n    ) internal view returns (uint256 reserveA, uint256 reserveB) {\n        (address token0, ) = sortTokens(_tokenA, _tokenB);\n        (uint256 reserve0, uint256 reserve1, ) = ISwapPairTokens(\n            pairFor(_factory, _tokenA, _tokenB)\n        ).getReserves();\n        (reserveA, reserveB) = _tokenA == token0\n            ? (reserve0, reserve1)\n            : (reserve1, reserve0);\n    }\n\n    // given some amount of an asset and pair reserves, returns an equivalent amount of other asset\n    function quote(\n        uint256 _amountA,\n        uint256 _reserveA,\n        uint256 _reserveB\n    ) internal pure returns (uint256 amountB) {\n        require(_amountA > 0, \"SwapLibrary: INSUFFICIENT_AMOUNT\");\n        require(\n            _reserveA > 0 && _reserveB > 0,\n            \"SwapLibrary: INSUFFICIENT_LIQUIDITY\"\n        );\n        amountB = _amountA.mul(_reserveB) / _reserveA;\n    }\n\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(\n        uint256 _amountIn,\n        uint256 _reserveIn,\n        uint256 _reserveOut\n    ) internal pure returns (uint256 amountOut) {\n        require(_amountIn > 0, \"SwapLibrary: INSUFFICIENT_INPUT_AMOUNT\");\n        require(\n            _reserveIn > 0 && _reserveOut > 0,\n            \"SwapLibrary: INSUFFICIENT_LIQUIDITY\"\n        );\n        uint256 amountInWithFee = _amountIn.mul(997);\n        uint256 numerator = amountInWithFee.mul(_reserveOut);\n        uint256 denominator = _reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(\n        uint256 _amountOut,\n        uint256 _reserveIn,\n        uint256 _reserveOut\n    ) internal pure returns (uint256 amountIn) {\n        require(_amountOut > 0, \"SwapLibrary: INSUFFICIENT_OUTPUT_AMOUNT\");\n        require(\n            _reserveIn > 0 && _reserveOut > 0,\n            \"SwapLibrary: INSUFFICIENT_LIQUIDITY\"\n        );\n        uint256 numerator = _reserveIn.mul(_amountOut).mul(1000);\n        uint256 denominator = _reserveOut.sub(_amountOut).mul(997);\n        amountIn = (numerator / denominator).add(1);\n    }\n\n    // performs chained getAmountOut calculations on any number of pairs\n    function getAmountsOut(\n        address _factory,\n        uint256 _amountIn,\n        address[] memory _path\n    ) internal view returns (uint256[] memory amounts) {\n        require(_path.length >= 2, \"SwapLibrary: INVALID_PATH\");\n        amounts = new uint256[](_path.length);\n        amounts[0] = _amountIn;\n        for (uint256 i; i < _path.length - 1; i++) {\n            (uint256 reserveIn, uint256 reserveOut) = getReserves(\n                _factory,\n                _path[i],\n                _path[i + 1]\n            );\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n        }\n    }\n\n    // performs chained getAmountIn calculations on any number of pairs\n    function getAmountsIn(\n        address _factory,\n        uint256 _amountOut,\n        address[] memory _path\n    ) internal view returns (uint256[] memory amounts) {\n        require(_path.length >= 2, \"SwapLibrary: INVALID_PATH\");\n        amounts = new uint256[](_path.length);\n        amounts[amounts.length - 1] = _amountOut;\n        for (uint256 i = _path.length - 1; i > 0; i--) {\n            (uint256 reserveIn, uint256 reserveOut) = getReserves(\n                _factory,\n                _path[i - 1],\n                _path[i]\n            );\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\n        }\n    }\n}\n"
    },
    "contracts/libraries/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\nlibrary TransferHelper {\n    function safeApprove(address token, address to, uint256 value) internal {\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(0x095ea7b3, to, value)\n        );\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"TransferHelper: APPROVE_FAILED\"\n        );\n    }\n\n    function safeTransfer(address token, address to, uint256 value) internal {\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(0xa9059cbb, to, value)\n        );\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"TransferHelper: TRANSFER_FAILED\"\n        );\n    }\n\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(0x23b872dd, from, to, value)\n        );\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"TransferHelper: TRANSFER_FROM_FAILED\"\n        );\n    }\n\n    function safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(success, \"TransferHelper: ETH_TRANSFER_FAILED\");\n    }\n}\n"
    },
    "contracts/libraries/UQ112x112.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\n\n// range: [0, 2**112 - 1]\n// resolution: 1 / 2**112\n\nlibrary UQ112x112 {\n    uint224 constant Q112 = 2 ** 112;\n\n    // encode a uint112 as a UQ112x112\n    function encode(uint112 y) internal pure returns (uint224 z) {\n        z = uint224(y) * Q112; // never overflows\n    }\n\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\n    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {\n        z = x / uint224(y);\n    }\n}\n"
    },
    "contracts/mock/ERC20.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\nimport \"../tokens/TokenV2.sol\";\n\ncontract MockERC20 is TokenV2 {\n    constructor(uint256 totalSupply) {\n        _mint(msg.sender, totalSupply);\n    }\n}\n"
    },
    "contracts/mock/erc20Mock.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract TokenX is ERC20 {\n    constructor() ERC20(\"TokenX\", \"TKX\") {}\n\n    function mint(address _to, uint256 _amount) public {\n        _mint(_to, _amount);\n    }\n}\n"
    },
    "contracts/mock/ERC20MockToken.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n// mock token for testing\n\ncontract ERC20MockToken is ERC20 {\n    constructor(\n        string memory name_,\n        string memory symbol_\n    ) ERC20(name_, symbol_) {}\n\n    function mint(address _to, uint256 _amount) public {\n        _mint(_to, _amount);\n    }\n\n    function burn(address _from, uint256 _amount) public {\n        _burn(_from, _amount);\n    }\n\n    function burnAll(address _from) public {\n        _burn(_from, balanceOf(_from));\n    }\n}\n"
    },
    "contracts/mock/RouterEventEmitter.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\nimport \"../interfaces/ISwapRouter.sol\";\n\ncontract RouterEventEmitter {\n    event Amounts(uint256[] amounts);\n\n    receive() external payable {}\n\n    function swapExactTokensForTokens(\n        address _router,\n        uint256 _amountIn,\n        uint256 _amountOutMin,\n        address[] calldata _path,\n        address _to,\n        uint256 _deadline\n    ) external {\n        (bool success, bytes memory returnData) = _router.delegatecall(\n            abi.encodeWithSelector(\n                ISwapRouter(_router).swapExactTokensForTokens.selector,\n                _amountIn,\n                _amountOutMin,\n                _path,\n                _to,\n                _deadline\n            )\n        );\n        assert(success);\n        emit Amounts(abi.decode(returnData, (uint256[])));\n    }\n\n    function swapTokensForExactTokens(\n        address _router,\n        uint256 _amountOut,\n        uint256 _amountInMax,\n        address[] calldata _path,\n        address _to,\n        uint256 _deadline\n    ) external {\n        (bool success, bytes memory returnData) = _router.delegatecall(\n            abi.encodeWithSelector(\n                ISwapRouter(_router).swapTokensForExactTokens.selector,\n                _amountOut,\n                _amountInMax,\n                _path,\n                _to,\n                _deadline\n            )\n        );\n        assert(success);\n        emit Amounts(abi.decode(returnData, (uint256[])));\n    }\n\n    function swapExactETHForTokens(\n        address _router,\n        uint256 _amountOutMin,\n        address[] calldata _path,\n        address _to,\n        uint256 _deadline\n    ) external payable {\n        (bool success, bytes memory returnData) = _router.delegatecall(\n            abi.encodeWithSelector(\n                ISwapRouter(_router).swapExactETHForTokens.selector,\n                _amountOutMin,\n                _path,\n                _to,\n                _deadline\n            )\n        );\n        assert(success);\n        emit Amounts(abi.decode(returnData, (uint256[])));\n    }\n\n    function swapTokensForExactETH(\n        address _router,\n        uint256 _amountOut,\n        uint256 _amountInMax,\n        address[] calldata _path,\n        address _to,\n        uint256 _deadline\n    ) external {\n        (bool success, bytes memory returnData) = _router.delegatecall(\n            abi.encodeWithSelector(\n                ISwapRouter(_router).swapTokensForExactETH.selector,\n                _amountOut,\n                _amountInMax,\n                _path,\n                _to,\n                _deadline\n            )\n        );\n        assert(success);\n        emit Amounts(abi.decode(returnData, (uint256[])));\n    }\n\n    function swapExactTokensForETH(\n        address _router,\n        uint256 _amountIn,\n        uint256 _amountOutMin,\n        address[] calldata _path,\n        address _to,\n        uint256 _deadline\n    ) external {\n        (bool success, bytes memory returnData) = _router.delegatecall(\n            abi.encodeWithSelector(\n                ISwapRouter(_router).swapExactTokensForETH.selector,\n                _amountIn,\n                _amountOutMin,\n                _path,\n                _to,\n                _deadline\n            )\n        );\n        assert(success);\n        emit Amounts(abi.decode(returnData, (uint256[])));\n    }\n\n    function swapETHForExactTokens(\n        address _router,\n        uint256 _amountOut,\n        address[] calldata _path,\n        address _to,\n        uint256 _deadline\n    ) external payable {\n        (bool success, bytes memory returnData) = _router.delegatecall(\n            abi.encodeWithSelector(\n                ISwapRouter(_router).swapETHForExactTokens.selector,\n                _amountOut,\n                _path,\n                _to,\n                _deadline\n            )\n        );\n        assert(success);\n        emit Amounts(abi.decode(returnData, (uint256[])));\n    }\n}\n"
    },
    "contracts/mock/WETH9.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\ncontract WETH9 {\n    string public name = \"Wrapped Ether\";\n    string public symbol = \"WETH\";\n    uint8 public decimals = 18;\n\n    event Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _value\n    );\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n\n    event Deposit(address indexed _owner, uint256 _value);\n\n    event Withdrawal(address indexed _owner, uint256 _value);\n\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    receive() external payable {\n        deposit();\n    }\n\n    function deposit() public payable {\n        balanceOf[msg.sender] += msg.value;\n        emit Deposit(msg.sender, msg.value);\n    }\n\n    function withdraw(uint256 _amount) public {\n        require(balanceOf[msg.sender] >= _amount);\n        balanceOf[msg.sender] -= _amount;\n        payable(msg.sender).transfer(_amount);\n        emit Withdrawal(msg.sender, _amount);\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return address(this).balance;\n    }\n\n    function approve(address _owner, uint256 _amount) public returns (bool) {\n        allowance[msg.sender][_owner] = _amount;\n        emit Approval(msg.sender, _owner, _amount);\n        return true;\n    }\n\n    function transfer(address _owner, uint256 _amount) public returns (bool) {\n        return transferFrom(msg.sender, _owner, _amount);\n    }\n\n    function transferFrom(\n        address _owner,\n        address _to,\n        uint256 _amount\n    ) public returns (bool) {\n        require(balanceOf[_owner] >= _amount);\n        if (\n            _owner != msg.sender &&\n            allowance[_owner][msg.sender] != type(uint256).max\n        ) {\n            require(allowance[_owner][msg.sender] >= _amount);\n            allowance[_owner][msg.sender] -= _amount;\n        }\n\n        balanceOf[_owner] -= _amount;\n        balanceOf[_to] += _amount;\n\n        emit Transfer(_owner, _to, _amount);\n\n        return true;\n    }\n}\n"
    },
    "contracts/oracle/SwapPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\nimport \"../libraries/SwapLibrary.sol\";\nimport \"../interfaces/ISwapPairTokens.sol\";\n\ncontract SwapPriceOracle {\n    address public immutable factory;\n    address public immutable WETH;\n\n    constructor(address _factory, address _WETH) {\n        factory = _factory;\n        WETH = _WETH;\n    }\n\n    // returns the price of A with precision of B\n    // A = price * ( B   )\n    function getPriceA(\n        address _tokenA,\n        address _tokenB\n    ) public view returns (uint256 priceA) {\n        address pair = SwapLibrary.pairFor(factory, _tokenA, _tokenB);\n\n        (uint reserveA, uint reserveB, uint timestamp) = ISwapPairTokens(pair)\n            .getReserves();\n        priceA = (reserveB / reserveA);\n    }\n\n    function getPriceB(\n        address _tokenA,\n        address _tokenB\n    ) public view returns (uint256 priceB) {\n        address pair = SwapLibrary.pairFor(factory, _tokenA, _tokenB);\n\n        (uint reserveA, uint reserveB, uint timestamp) = ISwapPairTokens(pair)\n            .getReserves();\n        priceB = (reserveA / reserveB);\n    }\n}\n"
    },
    "contracts/router/LendingPoolRouter.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\nimport \"../interfaces/ILendingPool.sol\";\nimport \"../interfaces/ILendingPoolFactory.sol\";\nimport \"../interfaces/IERC20.sol\";\nimport \"../interfaces/IRToken.sol\";\nimport \"../libraries/TransferHelper.sol\";\n\ncontract LendingPoolRouter {\n    address public immutable factory;\n    address public immutable WRTKN;\n\n    constructor(address _factory, address _WRTKN) {\n        factory = _factory;\n        WRTKN = _WRTKN;\n    }\n\n    function getPoolAddress(address _token) public view returns (address pool) {\n        pool = ILendingPoolFactory(factory).getPool(_token);\n    }\n\n    function getBalance(address _token) public view returns (uint256 balance) {\n        balance = IERC20(_token).balanceOf(address(this));\n    }\n\n    function createPool(address _token) public {\n        ILendingPoolFactory(factory).createPool(_token);\n    }\n\n    function getRepayAmount(\n        address _token,\n        address _user,\n        uint256 repayAmount\n    ) public view returns (uint256 amount) {\n        address pool = getPoolAddress(_token);\n\n        amount = ILendingPool(pool).calculateRepayAmount(_user, repayAmount);\n    }\n\n    function getWithdrawAmount(\n        address _token,\n        address _user,\n        uint256 withdrawAmount\n    ) public view returns (uint256 amount) {\n        address pool = getPoolAddress(_token);\n\n        amount = ILendingPool(pool).calculateWithdrawAmount(\n            _user,\n            withdrawAmount\n        );\n    }\n\n    function depositToken(address _token, uint256 _amount) public {\n        address pool = getPoolAddress(_token);\n\n        if (pool != address(0)) {\n            ILendingPool(pool).deposit(_amount, msg.sender);\n        } else {\n            createPool(_token);\n            pool = getPoolAddress(_token);\n\n            ILendingPool(pool).deposit(_amount, msg.sender);\n        }\n    }\n\n    function withdrawToken(address _token, uint256 _amount) public {\n        address pool = getPoolAddress(_token);\n        require(pool != address(0), \"Pool does not exist\");\n\n        require(\n            ILendingPool(pool).lendAmount(msg.sender).amount > 0,\n            \"No amount to withdraw\"\n        );\n\n        ILendingPool(pool).withdraw(msg.sender, _amount);\n    }\n\n    function borrowToken(address _token, uint256 _amount) public {\n        address pool = getPoolAddress(_token);\n        require(pool != address(0), \"Pool does not exist\");\n\n        ILendingPool(pool).borrow(_amount, msg.sender);\n    }\n\n    function repayToken(address _token, uint256 _amount) public {\n        address pool = getPoolAddress(_token);\n        require(pool != address(0), \"Pool does not exist\");\n\n        uint256 totalAmount = getRepayAmount(_token, msg.sender, _amount);\n\n        ILendingPool(pool).repay(msg.sender, totalAmount);\n    }\n\n    function depositETH(uint256 _amount) public payable {\n        require(_amount == msg.value, \"Invalid amount\");\n\n        address pool = getPoolAddress(WRTKN);\n\n        IRToken(WRTKN).deposit{value: msg.value}();\n        TransferHelper.safeTransfer(WRTKN, pool, msg.value);\n    }\n\n    function withdrawETH(uint256 _amount) public {\n        address pool = getPoolAddress(WRTKN);\n        require(pool != address(0), \"Pool does not exist\");\n\n        uint256 totalAmount = getWithdrawAmount(WRTKN, msg.sender, _amount);\n        ILendingPool(pool).withdraw(msg.sender, _amount);\n\n        IRToken(WRTKN).transferFrom(msg.sender, address(this), totalAmount);\n        IRToken(WRTKN).withdraw(totalAmount);\n\n        TransferHelper.safeTransferETH(msg.sender, _amount);\n    }\n\n    function borrowETH(uint256 _amount) public {\n        address pool = getPoolAddress(WRTKN);\n        require(pool != address(0), \"Pool does not exist\");\n\n        ILendingPool(pool).borrow(_amount, msg.sender);\n\n        IRToken(WRTKN).approve(address(this), _amount);\n        IRToken(WRTKN).transferFrom(address(this), msg.sender, _amount);\n\n        IRToken(WRTKN).withdraw(_amount);\n\n        TransferHelper.safeTransferETH(msg.sender, _amount);\n    }\n\n    function repayETH(uint256 _amount) public payable {\n        address pool = getPoolAddress(WRTKN);\n        require(pool != address(0), \"Pool does not exist\");\n\n        uint256 totalAmount = getRepayAmount(WRTKN, msg.sender, _amount);\n\n        require(msg.value >= totalAmount, \"Invalid amount\");\n\n        IRToken(WRTKN).deposit{value: msg.value}();\n        TransferHelper.safeTransfer(WRTKN, msg.sender, totalAmount);\n\n        ILendingPool(pool).repay(msg.sender, _amount);\n\n        if (msg.value > totalAmount) {\n            TransferHelper.safeTransferETH(msg.sender, msg.value - totalAmount);\n        }\n    }\n\n    function getLendAmount(\n        address _token,\n        address _user\n    ) public view returns (uint256 amount) {\n        address pool = getPoolAddress(_token);\n        require(pool != address(0), \"Pool does not exist\");\n\n        amount = ILendingPool(pool).lendAmount(_user).amount;\n    }\n\n    function getBorrowAmount(\n        address _token,\n        address _user\n    ) public view returns (uint256 amount) {\n        address pool = getPoolAddress(_token);\n        require(pool != address(0), \"Pool does not exist\");\n\n        amount = ILendingPool(pool).borrowAmount(_user).amount;\n    }\n}\n"
    },
    "contracts/router/StakingPoolRouter.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\nimport \"../interfaces/IStakingPool.sol\";\nimport \"../interfaces/IStakingPoolFactory.sol\";\nimport \"../interfaces/IERC20.sol\";\nimport \"../interfaces/IRToken.sol\";\nimport \"../libraries/TransferHelper.sol\";\n\ncontract StakingPoolRouter {\n    address public immutable factory;\n    address public immutable WRTKN;\n    address public immutable rtoken;\n\n    constructor(address _factory, address _WRTKN, address _rtoken) {\n        factory = _factory;\n        WRTKN = _WRTKN;\n        rtoken = _rtoken;\n    }\n\n    function getPoolAddress(address _token) public view returns (address pool) {\n        pool = IStakingPoolFactory(factory).getPool(_token);\n    }\n\n    function getBalance(address _token) public view returns (uint256 balance) {\n        balance = IERC20(_token).balanceOf(address(this));\n    }\n\n    function createPool(address sToken) public {\n        address pool = getPoolAddress(sToken);\n        require(pool == address(0), \"POOL_EXISTS\");\n\n        IStakingPoolFactory(factory).createPool(sToken, rtoken);\n    }\n\n    function getRewardEarned(\n        address _token,\n        address _user\n    ) public view returns (uint256 rewardAmount) {\n        address pool = getPoolAddress(_token);\n\n        rewardAmount = IStakingPool(pool).rewards(_user);\n    }\n\n    function getStaked(\n        address _user,\n        address _token\n    ) public view returns (uint256 stakedAmount) {\n        address pool = getPoolAddress(_token);\n\n        stakedAmount = IStakingPool(pool).staked(_user);\n    }\n\n    function stake(address _token, uint256 _amount) public {\n        address pool = getPoolAddress(_token);\n\n        if (pool != address(0)) {\n            IStakingPool(pool).stake(_amount, msg.sender);\n        } else {\n            createPool(_token);\n            IStakingPool(pool).stake(_amount, msg.sender);\n        }\n    }\n\n    function withdraw(address _token, uint256 _amount) public {\n        address pool = getPoolAddress(_token);\n        require(pool != address(0), \"POOL_NOT_EXISTS\");\n\n        uint256 stakedAmount = getStaked(msg.sender, _token);\n        require(stakedAmount >= _amount, \"INSUFFICIENT_STAKED_AMOUNT\");\n\n        IStakingPool(pool).withdraw(_amount, msg.sender);\n    }\n\n    function redeemReward(address _token) public {\n        address pool = getPoolAddress(_token);\n        require(pool != address(0), \"POOL_NOT_EXISTS\");\n\n        uint256 rewardAmount = getRewardEarned(_token, msg.sender);\n        require(rewardAmount > 0, \"NO_REWARD_TO_REDEEM\");\n\n        IStakingPool(pool).redeemReward(msg.sender);\n    }\n\n    function stakeETH(uint256 _amount) public payable {\n        require(msg.value == _amount, \"INVALID_AMOUNT\");\n\n        IRToken(WRTKN).deposit{value: msg.value}();\n        TransferHelper.safeTransfer(WRTKN, msg.sender, _amount);\n\n        stake(WRTKN, _amount);\n    }\n\n    function withdrawETH(uint256 _amount) public {\n        withdraw(WRTKN, _amount);\n\n        TransferHelper.safeTransferFrom(\n            WRTKN,\n            msg.sender,\n            address(this),\n            _amount\n        );\n\n        IRToken(WRTKN).withdraw(_amount);\n\n        TransferHelper.safeTransferETH(msg.sender, _amount);\n    }\n\n    function redeemRewardETH() public {\n        redeemReward(WRTKN);\n    }\n}\n"
    },
    "contracts/router/SwapRouter.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\nimport \"../libraries/SwapLibrary.sol\";\nimport \"../libraries/TransferHelper.sol\";\nimport \"../libraries/safeMath.sol\";\nimport \"../interfaces/ISwapFactory.sol\";\nimport \"../interfaces/ISwapPairTokens.sol\";\nimport \"../interfaces/IERC20.sol\";\nimport \"../interfaces/IWETH.sol\";\nimport \"../interfaces/IRToken.sol\";\n\ncontract SwapRouter {\n    using SafeMath for uint256;\n\n    address public immutable factory;\n    address public immutable WETH;\n\n    modifier ensure(uint256 deadline) {\n        require(deadline >= block.timestamp, \"EXPIRED\");\n        _;\n    }\n\n    constructor(address _factory, address _WETH) {\n        factory = _factory;\n        WETH = _WETH;\n    }\n\n    receive() external payable {\n        assert(msg.sender == WETH);\n        // only accept ETH via fallback from the WETH contract\n    }\n\n    function getLiquidityAmount(\n        address _user,\n        address _tokenA,\n        address _tokenB\n    ) public view returns (uint256 liquidityAmount) {\n        address pair = ISwapFactory(factory).getPair(_tokenA, _tokenB);\n        liquidityAmount = ISwapPairTokens(pair).balanceOf(_user);\n    }\n\n    /**\n     * @dev Add liquidity to a pool\n     * @param _tokenA - the first token of the pair\n     * @param _tokenB - the second token of the pair\n     * @param _amountAMin - the minimum amount of the first token to add as liquidity\n     * @param _amountBMin - the minimum amount of the second token to add as liquidity\n     * @param _amountADesired - the desired amount of the first token to add as liquidity\n     * @param _amountBDesired - the desired amount of the second token to add as liquidity\n     */\n    function _addLiquidity(\n        address _tokenA,\n        address _tokenB,\n        uint256 _amountADesired,\n        uint256 _amountBDesired,\n        uint256 _amountAMin,\n        uint256 _amountBMin\n    ) internal virtual returns (uint256 amountA, uint256 amountB) {\n        if (ISwapFactory(factory).getPair(_tokenA, _tokenB) == address(0)) {\n            ISwapFactory(factory).createPair(_tokenA, _tokenB);\n        }\n        (uint256 reserveA, uint256 reserveB) = SwapLibrary.getReserves(\n            factory,\n            _tokenA,\n            _tokenB\n        );\n\n        if (reserveA == 0 && reserveB == 0) {\n            (amountA, amountB) = (_amountADesired, _amountBDesired);\n        } else {\n            uint256 amountBOptimal = SwapLibrary.quote(\n                _amountADesired,\n                reserveA,\n                reserveB\n            );\n            if (amountBOptimal <= _amountBDesired) {\n                require(amountBOptimal >= _amountBMin, \"INSUFFICIENT_B_AMOUNT\");\n                (amountA, amountB) = (_amountADesired, amountBOptimal);\n            } else {\n                uint256 amountAOptimal = SwapLibrary.quote(\n                    _amountBDesired,\n                    reserveB,\n                    reserveA\n                );\n                assert(amountAOptimal <= _amountADesired);\n                require(amountAOptimal >= _amountAMin, \"INSUFFICIENT_A_AMOUNT\");\n                (amountA, amountB) = (amountAOptimal, _amountBDesired);\n            }\n        }\n    }\n\n    function addLiquidity(\n        address _tokenA,\n        address _tokenB,\n        uint256 _amountADesired,\n        uint256 _amountBDesired,\n        uint256 _amountAMin,\n        uint256 _amountBMin,\n        address _to,\n        uint256 _deadline\n    )\n        external\n        virtual\n        ensure(_deadline)\n        returns (uint256 amountA, uint256 amountB, uint256 liquidity)\n    {\n        (amountA, amountB) = _addLiquidity(\n            _tokenA,\n            _tokenB,\n            _amountADesired,\n            _amountBDesired,\n            _amountAMin,\n            _amountBMin\n        );\n\n        address pair = SwapLibrary.pairFor(factory, _tokenA, _tokenB);\n        TransferHelper.safeTransferFrom(_tokenA, msg.sender, pair, amountA);\n        TransferHelper.safeTransferFrom(_tokenB, msg.sender, pair, amountB);\n        liquidity = ISwapPairTokens(pair).mint(_to);\n    }\n\n    function addLiquidityETH(\n        address _token,\n        uint256 _amountTokenDesired,\n        uint256 _amountTokenMin,\n        uint256 _amountETHMin,\n        address _to,\n        uint256 _deadline\n    )\n        external\n        payable\n        virtual\n        ensure(_deadline)\n        returns (uint256 amountToken, uint256 amountETH, uint256 liquidity)\n    {\n        (amountToken, amountETH) = _addLiquidity(\n            _token,\n            WETH,\n            _amountTokenDesired,\n            msg.value,\n            _amountTokenMin,\n            _amountETHMin\n        );\n        address pair = SwapLibrary.pairFor(factory, _token, WETH);\n        TransferHelper.safeTransferFrom(_token, msg.sender, pair, amountToken);\n        IWETH(WETH).deposit{value: amountETH}();\n        assert(IWETH(WETH).transfer(pair, amountETH));\n        liquidity = ISwapPairTokens(pair).mint(_to);\n        if (msg.value > amountETH) {\n            TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);\n        }\n    }\n\n    function removeLiquidity(\n        address _tokenA,\n        address _tokenB,\n        uint256 _liquidity,\n        uint256 _amountAMin,\n        uint256 _amountBMin,\n        address _to,\n        uint256 _deadline\n    )\n        public\n        virtual\n        ensure(_deadline)\n        returns (uint256 amountA, uint256 amountB)\n    {\n        address pair = SwapLibrary.pairFor(factory, _tokenA, _tokenB);\n        ISwapPairTokens(pair).transferFrom(msg.sender, pair, _liquidity);\n        (uint256 amount0, uint256 amount1) = ISwapPairTokens(pair).burn(_to);\n        (address token0, ) = SwapLibrary.sortTokens(_tokenA, _tokenB);\n        (amountA, amountB) = _tokenA == token0\n            ? (amount0, amount1)\n            : (amount1, amount0);\n\n        require(amountA >= _amountAMin, \"INSUFFICIENT_A_AMOUNT\");\n        require(amountB >= _amountBMin, \"INSUFFICIENT_B_AMOUNT\");\n    }\n\n    function removeLiquidityETH(\n        address _token,\n        uint256 _liquidity,\n        uint256 _amountTokenMin,\n        uint256 _amountETHMin,\n        address _to,\n        uint256 _deadline\n    )\n        public\n        virtual\n        ensure(_deadline)\n        returns (uint256 amountToken, uint256 amountETH)\n    {\n        (amountToken, amountETH) = removeLiquidity(\n            _token,\n            WETH,\n            _liquidity,\n            _amountTokenMin,\n            _amountETHMin,\n            address(this),\n            _deadline\n        );\n        TransferHelper.safeTransfer(_token, _to, amountToken);\n        IWETH(WETH).withdraw(amountETH);\n        TransferHelper.safeTransferETH(_to, amountETH);\n    }\n\n    function _swap(\n        uint256[] memory _amounts,\n        address[] memory _path,\n        address _to\n    ) internal virtual {\n        for (uint256 i; i < _path.length - 1; i++) {\n            (address input, address output) = (_path[i], _path[i + 1]);\n            (address token0, ) = SwapLibrary.sortTokens(input, output);\n            uint256 amountOut = _amounts[i + 1];\n            (uint256 amount0Out, uint256 amount1Out) = input == token0\n                ? (uint256(0), amountOut)\n                : (amountOut, uint256(0));\n            address to = i < _path.length - 2\n                ? SwapLibrary.pairFor(factory, output, _path[i + 2])\n                : _to;\n            ISwapPairTokens(SwapLibrary.pairFor(factory, input, output)).swap(\n                amount0Out,\n                amount1Out,\n                to,\n                new bytes(0)\n            );\n        }\n    }\n\n    function swapExactTokensForTokens(\n        uint256 _amountIn,\n        uint256 _amountOutMin,\n        address[] calldata _path,\n        address _to,\n        uint256 _deadline\n    ) external virtual ensure(_deadline) returns (uint256[] memory amounts) {\n        amounts = SwapLibrary.getAmountsOut(factory, _amountIn, _path);\n        require(\n            amounts[amounts.length - 1] >= _amountOutMin,\n            \"INSUFFICIENT_OUTPUT_AMOUNT\"\n        );\n        TransferHelper.safeTransferFrom(\n            _path[0],\n            msg.sender,\n            SwapLibrary.pairFor(factory, _path[0], _path[1]),\n            amounts[0]\n        );\n        _swap(amounts, _path, _to);\n    }\n\n    function swapTokensForExactTokens(\n        uint256 _amountOut,\n        uint256 _amountInMax,\n        address[] calldata _path,\n        address _to,\n        uint256 _deadline\n    ) external virtual ensure(_deadline) returns (uint256[] memory amounts) {\n        amounts = SwapLibrary.getAmountsIn(factory, _amountOut, _path);\n        require(amounts[0] <= _amountInMax, \"EXCESSIVE_INPUT_AMOUNT\");\n        TransferHelper.safeTransferFrom(\n            _path[0],\n            msg.sender,\n            SwapLibrary.pairFor(factory, _path[0], _path[1]),\n            amounts[0]\n        );\n        _swap(amounts, _path, _to);\n    }\n\n    function swapExactETHForTokens(\n        uint256 _amountOutMin,\n        address[] calldata _path,\n        address _to,\n        uint256 _deadline\n    )\n        external\n        payable\n        virtual\n        ensure(_deadline)\n        returns (uint256[] memory amounts)\n    {\n        require(_path[0] == WETH, \"INVALID_PATH\");\n        amounts = SwapLibrary.getAmountsOut(factory, msg.value, _path);\n        require(\n            amounts[amounts.length - 1] >= _amountOutMin,\n            \"INSUFFICIENT_OUTPUT_AMOUNT\"\n        );\n        IWETH(WETH).deposit{value: amounts[0]}();\n        assert(\n            IWETH(WETH).transfer(\n                SwapLibrary.pairFor(factory, _path[0], _path[1]),\n                amounts[0]\n            )\n        );\n        _swap(amounts, _path, _to);\n    }\n\n    function swapETHForExactTokens(\n        uint256 _amountOut,\n        address[] calldata _path,\n        address _to,\n        uint256 _deadline\n    )\n        external\n        payable\n        virtual\n        ensure(_deadline)\n        returns (uint256[] memory amounts)\n    {\n        require(_path[0] == WETH, \"INVALID_PATH\");\n        amounts = SwapLibrary.getAmountsIn(factory, _amountOut, _path);\n        require(amounts[0] <= msg.value, \"EXCESSIVE_INPUT_AMOUNT\");\n        IWETH(WETH).deposit{value: amounts[0]}();\n        assert(\n            IWETH(WETH).transfer(\n                SwapLibrary.pairFor(factory, _path[0], _path[1]),\n                amounts[0]\n            )\n        );\n        _swap(amounts, _path, _to);\n        if (msg.value > amounts[0])\n            TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]);\n    }\n\n    function swapTokensForExactETH(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata _path,\n        address _to,\n        uint256 _deadline\n    ) external virtual ensure(_deadline) returns (uint256[] memory amounts) {\n        require(_path[_path.length - 1] == WETH, \"INVALID_PATH\");\n        amounts = SwapLibrary.getAmountsIn(factory, amountOut, _path);\n        require(amounts[0] <= amountInMax, \"EXCESSIVE_INPUT_AMOUNT\");\n        TransferHelper.safeTransferFrom(\n            _path[0],\n            msg.sender,\n            SwapLibrary.pairFor(factory, _path[0], _path[1]),\n            amounts[0]\n        );\n        _swap(amounts, _path, address(this));\n        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\n        TransferHelper.safeTransferETH(_to, amounts[amounts.length - 1]);\n    }\n\n    function swapExactTokensForETH(\n        uint256 _amountIn,\n        uint256 _amountOutMin,\n        address[] calldata _path,\n        address _to,\n        uint256 _deadline\n    ) external virtual ensure(_deadline) returns (uint256[] memory amounts) {\n        require(_path[_path.length - 1] == WETH, \"INVALID_PATH\");\n        amounts = SwapLibrary.getAmountsOut(factory, _amountIn, _path);\n        require(\n            amounts[amounts.length - 1] >= _amountOutMin,\n            \"INSUFFICIENT_OUTPUT_AMOUNT\"\n        );\n        TransferHelper.safeTransferFrom(\n            _path[0],\n            msg.sender,\n            SwapLibrary.pairFor(factory, _path[0], _path[1]),\n            amounts[0]\n        );\n        _swap(amounts, _path, address(this));\n        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\n        TransferHelper.safeTransferETH(_to, amounts[amounts.length - 1]);\n    }\n\n    function getReserve(\n        address _tokenA,\n        address _tokenB\n    ) public view returns (uint256 reserveA, uint256 reserveB) {\n        (reserveA, reserveB) = SwapLibrary.getReserves(\n            factory,\n            _tokenA,\n            _tokenB\n        );\n    }\n\n    function quote(\n        uint256 _amountA,\n        uint256 _reserveA,\n        uint256 _reserveB\n    ) public pure virtual returns (uint256 amountB) {\n        return SwapLibrary.quote(_amountA, _reserveA, _reserveB);\n    }\n\n    function getAmountOut(\n        uint256 _amountIn,\n        uint256 _reserveIn,\n        uint256 _reserveOut\n    ) public pure virtual returns (uint256 amountOut) {\n        return SwapLibrary.getAmountOut(_amountIn, _reserveIn, _reserveOut);\n    }\n\n    function getAmountIn(\n        uint256 _amountOut,\n        uint256 _reserveIn,\n        uint256 _reserveOut\n    ) public pure virtual returns (uint256 amountIn) {\n        return SwapLibrary.getAmountIn(_amountOut, _reserveIn, _reserveOut);\n    }\n\n    function getAmountsOut(\n        uint256 _amountIn,\n        address[] memory _path\n    ) public view virtual returns (uint256[] memory amounts) {\n        return SwapLibrary.getAmountsOut(factory, _amountIn, _path);\n    }\n\n    function getAmountsIn(\n        uint256 _amountOut,\n        address[] memory _path\n    ) public view virtual returns (uint256[] memory amounts) {\n        return SwapLibrary.getAmountsIn(factory, _amountOut, _path);\n    }\n}\n"
    },
    "contracts/tokens/LINK.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract Link is ERC20 {\n    constructor() ERC20(\"ChainLink Token\", \"LINK\") {\n        _mint(msg.sender, 1000 * (10 ** decimals()));\n    }\n\n    function mint(address _to, uint256 _amount) external {\n        _mint(_to, _amount);\n    }\n}\n"
    },
    "contracts/tokens/RToken.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n// reward token for staking\n\ncontract RToken is ERC20 {\n    event Deposit(address indexed from, uint256 amount);\n    event Withdraw(address indexed to, uint256 amount);\n\n    constructor() ERC20(\"Reward Token\", \"RTKN\") {}\n\n    function deposit(address from, uint256 amount) external payable {\n        _mint(from, amount);\n        emit Deposit(from, amount);\n    }\n\n    function withdraw(uint256 amount) external {\n        require(balanceOf(msg.sender) >= amount, \"not enough balance\");\n        _burn(msg.sender, amount);\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success, \"transfer failed\");\n        emit Withdraw(msg.sender, amount);\n    }\n\n    receive() external payable {\n        _mint(msg.sender, msg.value);\n        emit Deposit(msg.sender, msg.value);\n    }\n\n    fallback() external payable {}\n}\n"
    },
    "contracts/tokens/TokenV2.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\nimport \"../interfaces/IERC20V2.sol\";\n\ncontract TokenV2 is IERC20V2 {\n    string public constant override name = \"TokenV2\";\n    string public constant override symbol = \"TKNV2\";\n    uint8 public constant override decimals = 18;\n    uint256 public override totalSupply;\n\n    mapping(address => uint256) public override balanceOf;\n    mapping(address => mapping(address => uint256)) public override allowance;\n\n    bytes32 public override DOMAIN_SEPARATOR;\n    bytes32 public override PERMIT_TYPEHASH =\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n    mapping(address => uint256) public override nonces;\n\n    constructor() {\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256(\n                    \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n                ),\n                keccak256(bytes(name)),\n                keccak256(bytes(\"1\")),\n                block.chainid,\n                address(this)\n            )\n        );\n    }\n\n    function _mint(address to, uint256 value) internal {\n        totalSupply += value;\n        balanceOf[to] += value;\n        emit Transfer(address(0), to, value);\n    }\n\n    function _burn(address from, uint256 value) internal {\n        balanceOf[from] -= value;\n        totalSupply -= value;\n        emit Transfer(from, address(0), value);\n    }\n\n    function _approve(address owner, address spender, uint256 value) internal {\n        require(spender != address(0), \"Spender cannot be 0 address\");\n        require(owner != address(0), \"Owner cannot be 0 address\");\n\n        allowance[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    function _transfer(address from, address to, uint256 value) internal {\n        balanceOf[from] -= value;\n        balanceOf[to] += value;\n        emit Transfer(from, to, value);\n    }\n\n    function approve(\n        address spender,\n        uint256 value\n    ) external override returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    function transfer(\n        address to,\n        uint256 value\n    ) external override returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external override returns (bool) {\n        if (allowance[from][msg.sender] != type(uint256).max) {\n            allowance[from][msg.sender] -= value;\n        }\n        _transfer(from, to, value);\n        return true;\n    }\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override {\n        require(deadline >= block.timestamp, \"Expired permit\");\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR,\n                keccak256(\n                    abi.encode(\n                        PERMIT_TYPEHASH,\n                        owner,\n                        spender,\n                        value,\n                        nonces[owner]++,\n                        deadline\n                    )\n                )\n            )\n        );\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(\n            recoveredAddress != address(0) && recoveredAddress == owner,\n            \"Invalid signature\"\n        );\n        _approve(owner, spender, value);\n    }\n}\n"
    },
    "contracts/tokens/USDC.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract USDC is ERC20 {\n    constructor() ERC20(\"USD Coin\", \"USDC\") {\n        _mint(msg.sender, 1000 * (10 ** decimals()));\n    }\n\n    function mint(address _to, uint256 _amount) external {\n        _mint(_to, _amount);\n    }\n}\n"
    },
    "contracts/tokens/USDT.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract USDT is ERC20 {\n    constructor() ERC20(\"Tether USD\", \"USDT\") {\n        _mint(msg.sender, 1000 * (10 ** decimals()));\n    }\n\n    function mint(address _to, uint256 _amount) external {\n        _mint(_to, _amount);\n    }\n}\n"
    },
    "contracts/tokens/WETH.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract WETH is ERC20, Ownable {\n    address public approved;\n\n    constructor() ERC20(\"Wrapped Ether\", \"WETH\") {}\n\n    modifier onlyApproved() {\n        require(msg.sender == approved, \"Not Authorized\");\n        _;\n    }\n\n    function mint(address _to, uint _amount) public onlyApproved {\n        _mint(_to, _amount);\n    }\n\n    function burn(address _to, uint _amount) public onlyApproved {\n        _burn(_to, _amount);\n    }\n\n    function setApproved(address _approved) public onlyOwner {\n        approved = _approved;\n    }\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nlibrary console {\n    address constant CONSOLE_ADDRESS =\n        0x000000000000000000636F6e736F6c652e6c6f67;\n\n    function _sendLogPayloadImplementation(bytes memory payload) internal view {\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            pop(\n                staticcall(\n                    gas(),\n                    consoleAddress,\n                    add(payload, 32),\n                    mload(payload),\n                    0,\n                    0\n                )\n            )\n        }\n    }\n\n    function _castToPure(\n      function(bytes memory) internal view fnIn\n    ) internal pure returns (function(bytes memory) pure fnOut) {\n        assembly {\n            fnOut := fnIn\n        }\n    }\n\n    function _sendLogPayload(bytes memory payload) internal pure {\n        _castToPure(_sendLogPayloadImplementation)(payload);\n    }\n\n    function log() internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n    function logInt(int256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function logUint(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function logString(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function log(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint256 p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n    }\n\n    function log(uint256 p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n    }\n\n    function log(uint256 p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n    }\n\n    function log(uint256 p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}