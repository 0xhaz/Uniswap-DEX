{
  "language": "Solidity",
  "sources": {
    "contracts/core/StakingPool.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\nimport \"../interfaces/IERC20.sol\";\n\ncontract StakingPool {\n    IERC20 public rewardToken;\n    IERC20 public stakingToken;\n    uint256 private _totalSupply;\n    uint256 public rewardRate;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n    uint256 public decimalFactor;\n\n    mapping(address => uint256) public rewards;\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public staked;\n\n    /// @dev - modifier that will calculate the amount of rewards earned and add it to the rewards mapping\n    modifier updateReward(address _account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = block.timestamp;\n        rewards[_account] = rewardEarned(_account);\n        userRewardPerTokenPaid[_account] = rewardPerTokenStored;\n        _;\n    }\n\n    constructor(address _stakingToken, address _rewardToken) {\n        stakingToken = IERC20(_stakingToken);\n        rewardToken = IERC20(_rewardToken);\n\n        uint256 rewardTokenDecimals = rewardToken.decimals();\n        decimalFactor = 10 ** rewardTokenDecimals;\n    }\n\n    /// @dev - to stake tokens into the pool\n    /// @param _amount - the amount of tokens to stake\n    function stakeToken(\n        uint256 _amount,\n        address _user\n    ) external updateReward(_user) {\n        require(_amount > 0, \"Cannot stake 0 tokens\");\n        _totalSupply += _amount;\n        staked[_user] += _amount;\n        stakingToken.transferFrom(_user, address(this), _amount);\n    }\n\n    /// @dev - to withdraw tokens from the pool\n    /// @param _amount - the amount of tokens to withdraw\n    function withdrawToken(\n        uint256 _amount,\n        address _user\n    ) external updateReward(_user) {\n        require(_amount > 0, \"Cannot withdraw 0 tokens\");\n        _totalSupply -= _amount;\n        staked[_user] -= _amount;\n        stakingToken.transfer(_user, _amount);\n    }\n\n    /// @dev - To calculuate the amount of rewards per token staked\n    /// @return uint256 - The amount of rewards per token staked\n    function rewardPerToken() public view returns (uint256) {\n        if (_totalSupply == 0) {\n            return rewardPerTokenStored;\n        }\n\n        return\n            rewardPerTokenStored +\n            (((block.timestamp - lastUpdateTime) * rewardRate * decimalFactor) /\n                _totalSupply);\n    }\n\n    function getStakedAmount(address _user) public view returns (uint256) {\n        return staked[_user];\n    }\n\n    /**\n     * @dev - to calculate the earned rewards for a user based on the amount of tokens staked\n     * @param _account - the address of the user\n     * @return uint256 - the amount of rewards earned\n     */\n\n    function rewardEarned(address _account) public view returns (uint256) {\n        return\n            ((staked[_account] *\n                (rewardPerToken() - userRewardPerTokenPaid[_account])) /\n                decimalFactor) + rewards[_account];\n    }\n\n    function claimReward(address _user) external updateReward(msg.sender) {\n        uint256 reward = rewards[_user];\n        if (reward > 0) {\n            rewards[_user] = 0;\n            rewardToken.transfer(_user, reward);\n        }\n    }\n}\n"
    },
    "contracts/factory/StakingPoolFactory.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\nimport \"../core/StakingPool.sol\";\n\ncontract StakingPoolFactory {\n    address public feeTo;\n    address public feeToSetter;\n    address[] public allPools;\n\n    mapping(address => address) public getPool;\n\n    event PoolCreated(address indexed token, address pool, uint256 timestamp);\n\n    constructor(address _feeToSetter) {\n        feeToSetter = _feeToSetter;\n    }\n\n    function allPoolsLength() external view returns (uint256) {\n        return allPools.length;\n    }\n\n    /**\n     * @dev - Creates a new pool for the given token pair\n     * @dev - assembly is used to create the pool contract with the CREATE2 opcode\n     * @param _stakingToken - the token that will be staked\n     * @param _rewardToken  - the token that will be rewarded\n     * @return pool - the address of the pool that was created\n     *\n     */\n\n    function createPool(\n        address _stakingToken,\n        address _rewardToken\n    ) external returns (address pool) {\n        require(\n            getPool[_stakingToken] == address(0),\n            \"StakingPoolFactory::createPool: Pool already exists\"\n        );\n        require(\n            _stakingToken != address(0),\n            \"StakingPoolFactory::createPool: Invalid staking token\"\n        );\n\n        StakingPool _pool = new StakingPool(_stakingToken, _rewardToken);\n\n        getPool[_stakingToken] = address(_pool);\n        allPools.push(address(_pool));\n        emit PoolCreated(_stakingToken, address(_pool), block.timestamp);\n\n        return address(_pool);\n    }\n\n    function setFeeTo(address _feeTo) external {\n        require(\n            msg.sender == feeToSetter,\n            \"StakingPoolFactory::setFeeTo: FORBIDDEN\"\n        );\n        feeTo = _feeTo;\n    }\n\n    function setFeeToSetter(address _feeToSetter) external {\n        require(\n            msg.sender == feeToSetter,\n            \"StakingPoolFactory::setFeeToSetter: FORBIDDEN\"\n        );\n        feeToSetter = _feeToSetter;\n    }\n}\n"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\ninterface IERC20 {\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function totalSupply() external view returns (uint256);\n\n    function decimals() external view returns (uint256);\n\n    function balanceOf(address _owner) external view returns (uint256);\n\n    function allowance(\n        address _owner,\n        address _spender\n    ) external view returns (uint256);\n\n    function approve(address _spender, uint256 _value) external returns (bool);\n\n    function transfer(address _to, uint256 _value) external returns (bool);\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) external returns (bool);\n}\n"
    },
    "contracts/interfaces/IStakingPool.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\ninterface IStakingPool {\n    function rewardEarned(address _user) external view returns (uint256);\n\n    function stakeToken(uint256 _amount, address _account) external;\n\n    function withdrawToken(uint256 _amount, address _account) external;\n\n    function totalSupply() external view returns (uint256);\n\n    function rewardPerToken() external view returns (uint256);\n\n    function redeemReward(address _user) external;\n\n    function lastUpdateTime() external view returns (uint256);\n\n    function getStakedAmount(address _user) external view returns (uint256);\n\n    function claimReward(address _user) external;\n}\n"
    },
    "contracts/interfaces/IStakingPoolFactory.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\ninterface IStakingPoolFactory {\n    function getPool(address _token) external view returns (address);\n\n    function allPools() external view returns (address[] memory);\n\n    function allPoolsLength() external view returns (uint256);\n\n    function createPool(\n        address _token0,\n        address _token1\n    ) external returns (address);\n}\n"
    },
    "contracts/interfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\ninterface IWETH {\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Deposit(address indexed account, uint256 amount);\n    event Withdrawal(address indexed account, uint256 amount);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint256);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address _owner) external view returns (uint256);\n\n    function allowance(\n        address _owner,\n        address _spender\n    ) external view returns (uint256);\n\n    function approve(address _spender, uint256 _value) external returns (bool);\n\n    function transfer(address _to, uint256 _value) external returns (bool);\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) external returns (bool);\n\n    function deposit() external payable;\n\n    function withdraw(uint256 _amount) external;\n}\n"
    },
    "contracts/libraries/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\nlibrary TransferHelper {\n    function safeApprove(address token, address to, uint256 value) internal {\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(0x095ea7b3, to, value)\n        );\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"TransferHelper: APPROVE_FAILED\"\n        );\n    }\n\n    function safeTransfer(address token, address to, uint256 value) internal {\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(0xa9059cbb, to, value)\n        );\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"TransferHelper: TRANSFER_FAILED\"\n        );\n    }\n\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(0x23b872dd, from, to, value)\n        );\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"TransferHelper: TRANSFER_FROM_FAILED\"\n        );\n    }\n\n    function safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(success, \"TransferHelper: ETH_TRANSFER_FAILED\");\n    }\n}\n"
    },
    "contracts/router/StakingPoolRouter.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\nimport \"../interfaces/IStakingPool.sol\";\nimport \"../interfaces/IStakingPoolFactory.sol\";\nimport \"../interfaces/IERC20.sol\";\nimport \"../interfaces/IWETH.sol\";\nimport \"../libraries/TransferHelper.sol\";\n\ncontract StakingPoolRouter {\n    address public immutable factory;\n    address public immutable WETH;\n    address public immutable rtoken;\n\n    constructor(address _factory, address _WETH, address _rtoken) {\n        factory = _factory;\n        WETH = _WETH;\n        rtoken = _rtoken;\n    }\n\n    function getPoolAddress(address _token) public view returns (address pool) {\n        pool = IStakingPoolFactory(factory).getPool(_token);\n    }\n\n    function getBalance(address _token) public view returns (uint256 balance) {\n        balance = IERC20(_token).balanceOf(address(this));\n    }\n\n    function createPool(address sToken) public {\n        address pool = getPoolAddress(sToken);\n        require(pool == address(0), \"POOL_EXISTS\");\n\n        IStakingPoolFactory(factory).createPool(sToken, rtoken);\n    }\n\n    function getRewardEarned(\n        address _token,\n        address _user\n    ) public view returns (uint256 rewardAmount) {\n        address pool = getPoolAddress(_token);\n        require(pool != address(0), \"POOL_NOT_EXISTS\");\n\n        rewardAmount = IStakingPool(pool).rewardEarned(_user);\n    }\n\n    function getStaked(\n        address _user,\n        address _token\n    ) public view returns (uint256 stakedAmount) {\n        address pool = getPoolAddress(_token);\n\n        stakedAmount = IStakingPool(pool).getStakedAmount(_user);\n    }\n\n    function stake(address _token, uint256 _amount) public {\n        address pool = getPoolAddress(_token);\n\n        if (pool != address(0)) {\n            IStakingPool(pool).stakeToken(_amount, msg.sender);\n        } else {\n            createPool(_token);\n\n            IStakingPool(pool).stakeToken(_amount, msg.sender);\n        }\n    }\n\n    function withdraw(address _token, uint256 _amount) public {\n        address pool = getPoolAddress(_token);\n        require(pool != address(0), \"POOL_NOT_EXISTS\");\n\n        uint256 stakedAmount = getStaked(msg.sender, _token);\n        require(stakedAmount >= _amount, \"INSUFFICIENT_STAKED_AMOUNT\");\n\n        IStakingPool(pool).withdrawToken(_amount, msg.sender);\n    }\n\n    function redeemReward(address _token) public {\n        address pool = getPoolAddress(_token);\n        require(pool != address(0), \"POOL_NOT_EXISTS\");\n\n        uint256 rewardAmount = getRewardEarned(_token, msg.sender);\n        require(rewardAmount > 0, \"NO_REWARD_TO_REDEEM\");\n\n        IStakingPool(pool).claimReward(msg.sender);\n    }\n\n    function stakeETH(uint256 _amount) public payable {\n        require(msg.value == _amount, \"INVALID_AMOUNT\");\n\n        IWETH(WETH).deposit{value: msg.value}();\n        TransferHelper.safeTransfer(WETH, msg.sender, _amount);\n\n        stake(WETH, _amount);\n    }\n\n    function withdrawETH(uint256 _amount) public {\n        withdraw(WETH, _amount);\n\n        TransferHelper.safeTransferFrom(\n            WETH,\n            msg.sender,\n            address(this),\n            _amount\n        );\n\n        IWETH(WETH).withdraw(_amount);\n\n        TransferHelper.safeTransferETH(msg.sender, _amount);\n    }\n\n    function redeemRewardETH() public {\n        redeemReward(WETH);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}