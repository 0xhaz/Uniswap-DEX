{
  "language": "Solidity",
  "sources": {
    "contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\ninterface IERC20 {\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function totalSupply() external view returns (uint256);\n\n    function decimals() external view returns (uint256);\n\n    function balanceOf(address _owner) external view returns (uint256);\n\n    function allowance(\n        address _owner,\n        address _spender\n    ) external view returns (uint256);\n\n    function approve(address _spender, uint256 _value) external returns (bool);\n\n    function transfer(address _to, uint256 _value) external returns (bool);\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) external returns (bool);\n}\n"
    },
    "contracts/interfaces/IStakingPool.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\ninterface IStakingPool {\n    function rewardEarned(address _user) external view returns (uint256);\n\n    function stakeToken(uint256 _amount, address _account) external;\n\n    function withdrawToken(uint256 _amount, address _account) external;\n\n    function totalSupply() external view returns (uint256);\n\n    function rewardPerToken() external view returns (uint256);\n\n    function redeemReward(address _user) external;\n\n    function lastUpdateTime() external view returns (uint256);\n\n    function getStakedAmount(address _user) external view returns (uint256);\n\n    function claimReward(address _user) external;\n}\n"
    },
    "contracts/interfaces/IStakingPoolFactory.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\ninterface IStakingPoolFactory {\n    function getPool(address _token) external view returns (address);\n\n    function allPools() external view returns (address[] memory);\n\n    function allPoolsLength() external view returns (uint256);\n\n    function createPool(\n        address _token0,\n        address _token1\n    ) external returns (address);\n}\n"
    },
    "contracts/interfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\ninterface IWETH {\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Deposit(address indexed account, uint256 amount);\n    event Withdrawal(address indexed account, uint256 amount);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint256);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address _owner) external view returns (uint256);\n\n    function allowance(\n        address _owner,\n        address _spender\n    ) external view returns (uint256);\n\n    function approve(address _spender, uint256 _value) external returns (bool);\n\n    function transfer(address _to, uint256 _value) external returns (bool);\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) external returns (bool);\n\n    function deposit() external payable;\n\n    function withdraw(uint256 _amount) external;\n}\n"
    },
    "contracts/libraries/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\nlibrary TransferHelper {\n    function safeApprove(address token, address to, uint256 value) internal {\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(0x095ea7b3, to, value)\n        );\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"TransferHelper: APPROVE_FAILED\"\n        );\n    }\n\n    function safeTransfer(address token, address to, uint256 value) internal {\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(0xa9059cbb, to, value)\n        );\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"TransferHelper: TRANSFER_FAILED\"\n        );\n    }\n\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(0x23b872dd, from, to, value)\n        );\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"TransferHelper: TRANSFER_FROM_FAILED\"\n        );\n    }\n\n    function safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(success, \"TransferHelper: ETH_TRANSFER_FAILED\");\n    }\n}\n"
    },
    "contracts/router/StakingPoolRouter.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\nimport \"../interfaces/IStakingPool.sol\";\nimport \"../interfaces/IStakingPoolFactory.sol\";\nimport \"../interfaces/IERC20.sol\";\nimport \"../interfaces/IWETH.sol\";\nimport \"../libraries/TransferHelper.sol\";\n\ncontract StakingPoolRouter {\n    address public immutable factory;\n    address public immutable WETH;\n    address public immutable rtoken;\n\n    constructor(address _factory, address _WETH, address _rtoken) {\n        factory = _factory;\n        WETH = _WETH;\n        rtoken = _rtoken;\n    }\n\n    function getPoolAddress(address _token) public view returns (address pool) {\n        pool = IStakingPoolFactory(factory).getPool(_token);\n    }\n\n    function getBalance(address _token) public view returns (uint256 balance) {\n        balance = IERC20(_token).balanceOf(address(this));\n    }\n\n    function createPool(address sToken) public {\n        address pool = getPoolAddress(sToken);\n        require(pool == address(0), \"POOL_EXISTS\");\n\n        IStakingPoolFactory(factory).createPool(sToken, rtoken);\n    }\n\n    function getRewardEarned(\n        address _token,\n        address _user\n    ) public view returns (uint256 rewardAmount) {\n        address pool = getPoolAddress(_token);\n        require(pool != address(0), \"POOL_NOT_EXISTS\");\n\n        rewardAmount = IStakingPool(pool).rewardEarned(_user);\n    }\n\n    function getStaked(\n        address _user,\n        address _token\n    ) public view returns (uint256 stakedAmount) {\n        address pool = getPoolAddress(_token);\n\n        stakedAmount = IStakingPool(pool).getStakedAmount(_user);\n    }\n\n    function stake(address _token, uint256 _amount) public {\n        address pool = getPoolAddress(_token);\n\n        if (pool != address(0)) {\n            IStakingPool(pool).stakeToken(_amount, msg.sender);\n        } else {\n            createPool(_token);\n\n            pool = getPoolAddress(_token);\n\n            IStakingPool(pool).stakeToken(_amount, msg.sender);\n        }\n    }\n\n    function withdraw(address _token, uint256 _amount) public {\n        address pool = getPoolAddress(_token);\n        require(pool != address(0), \"POOL_NOT_EXISTS\");\n\n        uint256 stakedAmount = getStaked(msg.sender, _token);\n        require(stakedAmount >= _amount, \"INSUFFICIENT_STAKED_AMOUNT\");\n\n        IStakingPool(pool).withdrawToken(_amount, msg.sender);\n    }\n\n    function redeemReward(address _token) public {\n        address pool = getPoolAddress(_token);\n        require(pool != address(0), \"POOL_NOT_EXISTS\");\n\n        uint256 rewardAmount = getRewardEarned(_token, msg.sender);\n        require(rewardAmount > 0, \"NO_REWARD_TO_REDEEM\");\n\n        IStakingPool(pool).claimReward(msg.sender);\n    }\n\n    function stakeETH(uint256 _amount) public payable {\n        require(msg.value == _amount, \"INVALID_AMOUNT\");\n\n        IWETH(WETH).deposit{value: msg.value}();\n        TransferHelper.safeTransfer(WETH, msg.sender, _amount);\n\n        stake(WETH, _amount);\n    }\n\n    function withdrawETH(uint256 _amount) public {\n        withdraw(WETH, _amount);\n\n        TransferHelper.safeTransferFrom(\n            WETH,\n            msg.sender,\n            address(this),\n            _amount\n        );\n\n        IWETH(WETH).withdraw(_amount);\n\n        TransferHelper.safeTransferETH(msg.sender, _amount);\n    }\n\n    function redeemRewardETH() public {\n        redeemReward(WETH);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}