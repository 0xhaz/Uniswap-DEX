{
  "language": "Solidity",
  "sources": {
    "contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\ninterface IERC20 {\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function totalSupply() external view returns (uint256);\n\n    function decimals() external view returns (uint256);\n\n    function balanceOf(address _owner) external view returns (uint256);\n\n    function allowance(\n        address _owner,\n        address _spender\n    ) external view returns (uint256);\n\n    function approve(address _spender, uint256 _value) external returns (bool);\n\n    function transfer(address _to, uint256 _value) external returns (bool);\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) external returns (bool);\n}\n"
    },
    "contracts/interfaces/ILendingPool.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\ninterface ILendingPool {\n    struct Amount {\n        uint256 amount;\n        uint256 start;\n    }\n\n    function lendAmount(address _user) external view returns (Amount memory);\n\n    function earnedInterest(address _user) external view returns (uint256);\n\n    function borrowAmount(address _user) external view returns (Amount memory);\n\n    function payInterest(address user) external view returns (uint256);\n\n    function lenders(address _user) external view returns (bool);\n\n    function borrowers(address _user) external view returns (bool);\n\n    function deposit(uint256 _amount, address _user) external;\n\n    function borrow(uint256 _amount, address _user) external;\n\n    function repay(address _user, uint256 _amount) external;\n\n    function withdraw(address _user, uint256 _amount) external;\n\n    function liquidate(address _user, uint256 _amount) external;\n\n    function calculateRepayAmount(\n        address _user,\n        uint256 _amount\n    ) external view returns (uint256);\n\n    function calculateWithdrawAmount(\n        address _user,\n        uint256 _amount\n    ) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/ILendingPoolFactory.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\ninterface ILendingPoolFactory {\n    function getPool(address _token) external view returns (address);\n\n    function allPools() external view returns (address[] memory);\n\n    function allPoolsLength() external view returns (uint256);\n\n    function createPool(address _token) external returns (address);\n}\n"
    },
    "contracts/interfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\ninterface IWETH {\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Deposit(address indexed account, uint256 amount);\n    event Withdrawal(address indexed account, uint256 amount);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint256);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address _owner) external view returns (uint256);\n\n    function allowance(\n        address _owner,\n        address _spender\n    ) external view returns (uint256);\n\n    function approve(address _spender, uint256 _value) external returns (bool);\n\n    function transfer(address _to, uint256 _value) external returns (bool);\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) external returns (bool);\n\n    function deposit() external payable;\n\n    function withdraw(uint256 _amount) external;\n}\n"
    },
    "contracts/libraries/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\nlibrary TransferHelper {\n    function safeApprove(address token, address to, uint256 value) internal {\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(0x095ea7b3, to, value)\n        );\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"TransferHelper: APPROVE_FAILED\"\n        );\n    }\n\n    function safeTransfer(address token, address to, uint256 value) internal {\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(0xa9059cbb, to, value)\n        );\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"TransferHelper: TRANSFER_FAILED\"\n        );\n    }\n\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(0x23b872dd, from, to, value)\n        );\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"TransferHelper: TRANSFER_FROM_FAILED\"\n        );\n    }\n\n    function safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(success, \"TransferHelper: ETH_TRANSFER_FAILED\");\n    }\n}\n"
    },
    "contracts/router/LendingPoolRouter.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\nimport \"../interfaces/ILendingPool.sol\";\nimport \"../interfaces/ILendingPoolFactory.sol\";\nimport \"../interfaces/IERC20.sol\";\nimport \"../interfaces/IWETH.sol\";\nimport \"../libraries/TransferHelper.sol\";\n\ncontract LendingPoolRouter {\n    address public immutable factory;\n    address public immutable WETH;\n\n    constructor(address _factory, address _WETH) {\n        factory = _factory;\n        WETH = _WETH;\n    }\n\n    function getPoolAddress(address _token) public view returns (address pool) {\n        pool = ILendingPoolFactory(factory).getPool(_token);\n    }\n\n    function getBalance(address _token) public view returns (uint256 balance) {\n        balance = IERC20(_token).balanceOf(address(this));\n    }\n\n    function createPool(address _token) public {\n        ILendingPoolFactory(factory).createPool(_token);\n    }\n\n    function getRepayAmount(\n        address _token,\n        address _user,\n        uint256 repayAmount\n    ) public view returns (uint256 amount) {\n        address pool = getPoolAddress(_token);\n\n        amount = ILendingPool(pool).calculateRepayAmount(_user, repayAmount);\n    }\n\n    function getWithdrawAmount(\n        address _token,\n        address _user,\n        uint256 withdrawAmount\n    ) public view returns (uint256 amount) {\n        address pool = getPoolAddress(_token);\n\n        amount = ILendingPool(pool).calculateWithdrawAmount(\n            _user,\n            withdrawAmount\n        );\n    }\n\n    function depositToken(address _token, uint256 _amount) public {\n        address pool = getPoolAddress(_token);\n\n        if (pool != address(0)) {\n            ILendingPool(pool).deposit(_amount, msg.sender);\n        } else {\n            createPool(_token);\n            pool = getPoolAddress(_token);\n\n            ILendingPool(pool).deposit(_amount, msg.sender);\n        }\n    }\n\n    function withdrawToken(address _token, uint256 _amount) public {\n        address pool = getPoolAddress(_token);\n        require(pool != address(0), \"Pool does not exist\");\n\n        require(\n            ILendingPool(pool).lendAmount(msg.sender).amount > 0,\n            \"No amount to withdraw\"\n        );\n\n        ILendingPool(pool).withdraw(msg.sender, _amount);\n    }\n\n    function borrowToken(address _token, uint256 _amount) public {\n        address pool = getPoolAddress(_token);\n        require(pool != address(0), \"Pool does not exist\");\n\n        ILendingPool(pool).borrow(_amount, msg.sender);\n    }\n\n    function repayToken(address _token, uint256 _amount) public {\n        address pool = getPoolAddress(_token);\n        require(pool != address(0), \"Pool does not exist\");\n\n        uint256 totalAmount = getRepayAmount(_token, msg.sender, _amount);\n\n        ILendingPool(pool).repay(msg.sender, totalAmount);\n    }\n\n    function depositETH(uint256 _amount) public payable {\n        require(_amount == msg.value, \"Invalid amount\");\n\n        address pool = getPoolAddress(WETH);\n\n        IWETH(WETH).deposit{value: msg.value}();\n        TransferHelper.safeTransfer(WETH, pool, msg.value);\n    }\n\n    function withdrawETH(uint256 _amount) public {\n        address pool = getPoolAddress(WETH);\n        require(pool != address(0), \"Pool does not exist\");\n\n        uint256 totalAmount = getWithdrawAmount(WETH, msg.sender, _amount);\n        ILendingPool(pool).withdraw(msg.sender, _amount);\n\n        IWETH(WETH).transferFrom(msg.sender, address(this), totalAmount);\n        IWETH(WETH).withdraw(totalAmount);\n\n        TransferHelper.safeTransferETH(msg.sender, _amount);\n    }\n\n    function borrowETH(uint256 _amount) public {\n        address pool = getPoolAddress(WETH);\n        require(pool != address(0), \"Pool does not exist\");\n\n        ILendingPool(pool).borrow(_amount, msg.sender);\n\n        IWETH(WETH).approve(address(this), _amount);\n        IWETH(WETH).transferFrom(address(this), msg.sender, _amount);\n\n        IWETH(WETH).withdraw(_amount);\n\n        TransferHelper.safeTransferETH(msg.sender, _amount);\n    }\n\n    function repayETH(uint256 _amount) public payable {\n        address pool = getPoolAddress(WETH);\n        require(pool != address(0), \"Pool does not exist\");\n\n        uint256 totalAmount = getRepayAmount(WETH, msg.sender, _amount);\n\n        require(msg.value >= totalAmount, \"Invalid amount\");\n\n        IWETH(WETH).deposit{value: msg.value}();\n        TransferHelper.safeTransfer(WETH, msg.sender, totalAmount);\n\n        ILendingPool(pool).repay(msg.sender, _amount);\n\n        if (msg.value > totalAmount) {\n            TransferHelper.safeTransferETH(msg.sender, msg.value - totalAmount);\n        }\n    }\n\n    function getLendAmount(\n        address _token,\n        address _user\n    ) public view returns (uint256 amount) {\n        address pool = getPoolAddress(_token);\n        require(pool != address(0), \"Pool does not exist\");\n\n        amount = ILendingPool(pool).lendAmount(_user).amount;\n    }\n\n    function getBorrowAmount(\n        address _token,\n        address _user\n    ) public view returns (uint256 amount) {\n        address pool = getPoolAddress(_token);\n        require(pool != address(0), \"Pool does not exist\");\n\n        amount = ILendingPool(pool).borrowAmount(_user).amount;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}