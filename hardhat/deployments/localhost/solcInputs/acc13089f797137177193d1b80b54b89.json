{
  "language": "Solidity",
  "sources": {
    "contracts/core/SwapPairTokens.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\nimport \"../libraries/Math.sol\";\nimport \"../libraries/UQ112x112.sol\";\nimport \"../interfaces/IERC20.sol\";\nimport \"../interfaces/ISwapFactory.sol\";\nimport \"./SwapTokens.sol\";\n\ncontract SwapPairTokens is SwapTokens {\n    using SafeMath for uint256;\n    using UQ112x112 for uint224;\n\n    uint256 public constant MINIMUM_LIQUIDITY = 10 ** 3;\n    bytes4 private constant SELECTOR =\n        bytes4(keccak256(bytes(\"transfer(address,uint256)\")));\n\n    address public factory;\n    address public token0;\n    address public token1;\n\n    uint112 private reserve0; // uses single storage slot, accessible via getReserves\n    uint112 private reserve1; // uses single storage slot, accessible via getReserves\n    uint32 private blockTimestampLast; // uses single storage slot, accessible via getReserves\n\n    uint256 public price0CumulativeLast;\n    uint256 public price1CumulativeLast;\n    uint256 public kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity event\n\n    uint256 private unlocked = 1;\n\n    modifier lock() {\n        require(unlocked == 1, \"SwapPairTokens: LOCKED\");\n        unlocked = 0;\n        _;\n        unlocked = 1;\n    }\n\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n    event Burn(\n        address indexed sender,\n        uint256 amount0,\n        uint256 amount1,\n        address indexed to\n    );\n    event Swap(\n        address indexed sender,\n        uint256 amount0In,\n        uint256 amount1In,\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address indexed to\n    );\n    event Sync(uint256 reserve0, uint256 reserve1);\n\n    constructor() {\n        factory = msg.sender;\n    }\n\n    function getReserves()\n        public\n        view\n        returns (\n            uint112 _reserve0,\n            uint112 _reserve1,\n            uint32 _blockTimestampLast\n        )\n    {\n        _reserve0 = reserve0;\n        _reserve1 = reserve1;\n        _blockTimestampLast = blockTimestampLast;\n    }\n\n    // called once by the factory at time of deployment\n    function initialize(address _token0, address _token1) external {\n        require(msg.sender == factory, \"SwapPairTokens: FORBIDDEN\"); // sufficient check\n        token0 = _token0;\n        token1 = _token1;\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function burn(\n        address _to\n    ) external lock returns (uint256 _amount0, uint256 _amount1) {\n        (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\n        address _token0 = token0; // gas savings\n        address _token1 = token1; // gas savings\n        uint256 balance0 = IERC20(_token0).balanceOf(address(this));\n        uint256 balance1 = IERC20(_token1).balanceOf(address(this));\n        uint256 liquidity = balanceOf[address(this)];\n\n        bool feeOn = _collectFee(_reserve0, _reserve1);\n        uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\n        _amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution\n        _amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution\n        require(\n            _amount0 > 0 && _amount1 > 0,\n            \"SwapPairTokens: INSUFFICIENT_LIQUIDITY_BURNED\"\n        );\n        _burn(address(this), liquidity);\n        _safeTransfer(_token0, _to, _amount0);\n        _safeTransfer(_token1, _to, _amount1);\n        balance0 = IERC20(_token0).balanceOf(address(this));\n        balance1 = IERC20(_token1).balanceOf(address(this));\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        if (feeOn) kLast = uint256(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date\n        emit Burn(msg.sender, _amount0, _amount1, _to);\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function mint(address _to) external lock returns (uint256 liquidity) {\n        (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\n        uint256 balance0 = IERC20(token0).balanceOf(address(this));\n        uint256 balance1 = IERC20(token1).balanceOf(address(this));\n        uint256 amount0 = balance0.sub(_reserve0);\n        uint256 amount1 = balance1.sub(_reserve1);\n\n        bool feeOn = _collectFee(_reserve0, _reserve1);\n        uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\n        if (_totalSupply == 0) {\n            liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);\n            _mint(address(0), MINIMUM_LIQUIDITY);\n            // permanently lock the first MINIMUM_LIQUIDITY tokens\n        } else {\n            liquidity = Math.min(\n                balance0.mul(_totalSupply) / _reserve0,\n                balance1.mul(_totalSupply) / _reserve1\n            );\n        }\n        require(liquidity > 0, \"SwapPairTokens: INSUFFICIENT_LIQUIDITY_MINTED\");\n        _mint(_to, liquidity);\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        if (feeOn) kLast = uint256(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date\n        emit Mint(msg.sender, amount0, amount1);\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function swap(\n        uint256 _amount0Out,\n        uint256 _amount1Out,\n        address _to,\n        bytes calldata _data\n    ) external lock {\n        require(\n            _amount0Out > 0 || _amount1Out > 0,\n            \"SwapPairTokens: INSUFFICIENT_OUTPUT_AMOUNT\"\n        );\n        (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\n        require(\n            _amount0Out < _reserve0 && _amount1Out < _reserve1,\n            \"SwapPairTokens: INSUFFICIENT_LIQUIDITY\"\n        );\n\n        uint256 balance0;\n        uint256 balance1;\n        {\n            // scope for _token{0,1}, avoids stack too deep errors\n            address _token0 = token0;\n            address _token1 = token1;\n            require(\n                _to != _token0 && _to != _token1,\n                \"SwapPairTokens: INVALID_TO\"\n            );\n            if (_amount0Out > 0) _safeTransfer(_token0, _to, _amount0Out); // optimistically transfer tokens\n            if (_amount1Out > 0) _safeTransfer(_token1, _to, _amount1Out); // optimistically transfer tokens\n            balance0 = IERC20(_token0).balanceOf(address(this));\n            balance1 = IERC20(_token1).balanceOf(address(this));\n        }\n        uint256 amount0In = balance0 > _reserve0 - _amount0Out\n            ? balance0 - (_reserve0 - _amount0Out)\n            : 0;\n        uint256 amount1In = balance1 > _reserve1 - _amount1Out\n            ? balance1 - (_reserve1 - _amount1Out)\n            : 0;\n        require(\n            amount0In > 0 || amount1In > 0,\n            \"SwapPairTokens: INSUFFICIENT_INPUT_AMOUNT\"\n        );\n        {\n            // scope for reserve{0,1}Adjusted, avoids stack too deep errors\n            uint256 balance0Adjusted = (\n                balance0.mul(1000).sub(amount0In.mul(3))\n            );\n            uint256 balance1Adjusted = (\n                balance1.mul(1000).sub(amount1In.mul(3))\n            );\n            require(\n                balance0Adjusted.mul(balance1Adjusted) >=\n                    uint256(_reserve0).mul(_reserve1).mul(1000 ** 2),\n                \"SwapPairTokens: K\"\n            );\n        }\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n\n        emit Swap(\n            msg.sender,\n            amount0In,\n            amount1In,\n            _amount0Out,\n            _amount1Out,\n            _to\n        );\n    }\n\n    // force balances to match reserves\n    function skim(address _to) external lock {\n        address _token0 = token0; // gas savings\n        address _token1 = token1; // gas savings\n        _safeTransfer(\n            _token0,\n            _to,\n            IERC20(_token0).balanceOf(address(this)).sub(reserve0)\n        );\n        _safeTransfer(\n            _token1,\n            _to,\n            IERC20(_token1).balanceOf(address(this)).sub(reserve1)\n        );\n    }\n\n    // force reserves to match balances\n    function sync() external lock {\n        _update(\n            IERC20(token0).balanceOf(address(this)),\n            IERC20(token1).balanceOf(address(this)),\n            reserve0,\n            reserve1\n        );\n    }\n\n    // update reserves and, on the first call per block, price accumulators\n    function _update(\n        uint256 balance0,\n        uint256 balance1,\n        uint112 _reserve0,\n        uint112 _reserve1\n    ) private {\n        require(\n            balance0 <= (2 ** 122 - 1) && balance1 <= (2 ** 122 - 1),\n            \"SwapPairTokens: OVERFLOW\"\n        );\n        uint32 blockTimestamp = uint32(block.timestamp % 2 ** 32);\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\n        if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {\n            // * never overflows, and + overflow is desired\n            price0CumulativeLast +=\n                uint256(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) *\n                timeElapsed;\n            price1CumulativeLast +=\n                uint256(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) *\n                timeElapsed;\n        }\n        reserve0 = uint112(balance0);\n        reserve1 = uint112(balance1);\n        blockTimestampLast = blockTimestamp;\n        emit Sync(reserve0, reserve1);\n    }\n\n    // if fee is on, mint liquidity equivalent to 1/6th of the growth in sqrt(k)\n    function _collectFee(\n        uint112 _reserve0,\n        uint112 _reserve1\n    ) private returns (bool feeOn) {\n        address feeTo = ISwapFactory(factory).feeTo();\n        feeOn = feeTo != address(0);\n        uint256 _kLast = kLast; // gas savings\n        if (feeOn) {\n            if (_kLast != 0) {\n                uint256 rootK = Math.sqrt(uint256(_reserve0).mul(_reserve1));\n                uint256 rootKLast = Math.sqrt(_kLast);\n                if (rootK > rootKLast) {\n                    uint256 numerator = totalSupply.mul(rootK.sub(rootKLast));\n                    uint256 denominator = rootK.mul(5).add(rootKLast);\n                    uint256 liquidity = numerator / denominator;\n                    if (liquidity > 0) _mint(feeTo, liquidity);\n                }\n            }\n        } else if (_kLast != 0) {\n            kLast = 0;\n        }\n    }\n\n    function _safeTransfer(\n        address _token,\n        address _to,\n        uint256 _value\n    ) private {\n        (bool success, bytes memory data) = _token.call(\n            abi.encodeWithSelector(SELECTOR, _to, _value)\n        );\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"SwapPairTokens: TRANSFER_FAILED\"\n        );\n    }\n}\n"
    },
    "contracts/core/SwapPairTokens2.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\nimport \"./SwapTokens.sol\";\nimport \"../interfaces/IERC20.sol\";\n\ncontract SwapPairTokens2 is SwapTokens {\n    IERC20 public immutable token0;\n    IERC20 public immutable token1;\n\n    // tracks the internal balances of the pool\n    uint256 public reserve0;\n    uint256 public reserve1;\n\n    uint256 public price0CumulativeLast;\n    uint256 public price1CumulativeLast;\n    uint256 public kLast;\n\n    constructor(address _token0, address _token1) {\n        token0 = IERC20(_token0);\n        token1 = IERC20(_token1);\n    }\n\n    // swap tokens\n    function swap(\n        address _tokenIn,\n        uint256 _amountIn\n    ) external returns (uint256 amountOut) {\n        require(\n            _tokenIn == address(token0) || _tokenIn == address(token1),\n            \"INVALID TOKEN\"\n        );\n        require(_amountIn > 0, \"INSUFFICIENT INPUT AMOUNT\");\n\n        bool isToken0 = _tokenIn == address(token0);\n\n        // assigning the tokens to the correct variables\n        (\n            IERC20 tokenIn,\n            IERC20 tokenOut,\n            uint256 reserveIn,\n            uint256 reserveOut\n        ) = isToken0\n                ? (token0, token1, reserve0, reserve1)\n                : (token1, token0, reserve1, reserve0);\n\n        // transferring the tokens from the sender to the contract\n        tokenIn.transferFrom(msg.sender, address(this), _amountIn);\n\n        // fee calculation of 0.3%\n        uint256 _amountInWithFee = (_amountIn * 997) / 1000;\n\n        /**\n         * ydx / (x + dx) = dy\n         * y = reserveOut, dy = _amountOut\n         * x = reserveIn, dx = _amountInWithFee\n         */\n        amountOut =\n            (reserveOut * _amountInWithFee) /\n            (reserveIn + _amountInWithFee);\n\n        // tokenOut transfer to the sender\n        tokenOut.transfer(msg.sender, amountOut);\n\n        // updating the reserves\n        _update(\n            token0.balanceOf(address(this)),\n            token1.balanceOf(address(this))\n        );\n    }\n\n    function addLiquidity(\n        uint256 _amount0,\n        uint256 _amount1\n    ) external returns (uint256 shares) {\n        token0.transferFrom(msg.sender, address(this), _amount0);\n        token1.transferFrom(msg.sender, address(this), _amount1);\n\n        if (reserve0 > 0 || reserve1 > 0) {\n            require(\n                reserve0 * _amount1 == reserve1 * _amount0,\n                \"x / y != dx / dy\"\n            );\n        }\n\n        if (totalSupply == 0) {\n            shares = _sqrt(_amount0 * _amount1);\n        } else {\n            // whichever value is the minimum will be the shares of (dx * T / x) or (dy * T / y\n            shares = _min(\n                (_amount0 * totalSupply) / reserve0,\n                (_amount1 * totalSupply) / reserve1\n            );\n        }\n    }\n\n    function removeLiquidity(\n        uint256 _shares\n    ) external returns (uint256 amount0, uint256 amount1) {\n        uint256 bal0 = token0.balanceOf(address(this));\n        uint256 bal1 = token1.balanceOf(address(this));\n\n        // calculating the amount of tokens to be transferred\n        amount0 = (bal0 * _shares) / totalSupply;\n        amount1 = (bal1 * _shares) / totalSupply;\n        require(amount0 > 0 && amount1 > 0, \"INSUFFICIENT LIQUIDITY\");\n\n        // burning the shares and updating the reserves\n        _burn(msg.sender, _shares);\n        _update(bal0 - amount0, bal1 - amount1);\n\n        // transferring the tokens to the sender\n        token0.transfer(msg.sender, amount0);\n        token1.transfer(msg.sender, amount1);\n    }\n\n    // to update the reserver of the pool\n    function _update(uint256 _reserve0, uint256 _reserve1) private {\n        require(\n            _reserve0 <= type(uint112).max && _reserve1 <= type(uint112).max,\n            \"OVERFLOW\"\n        );\n        reserve0 = _reserve0;\n        reserve1 = _reserve1;\n    }\n\n    // to calculate the square root of the number\n    function _sqrt(uint256 y) private pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n\n    // to find the minimum of the two numbers\n    function _min(uint256 x, uint256 y) private pure returns (uint256) {\n        return x = x <= y ? x : y;\n    }\n}\n"
    },
    "contracts/core/SwapTokens.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\nimport \"../libraries/safeMath.sol\";\n\ncontract SwapTokens {\n    using SafeMath for uint256;\n\n    string public constant name = \"SwapTokens\";\n    string public constant symbol = \"SWT\";\n    uint8 public constant decimals = 18;\n\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    mapping(address => uint256) public nonces;\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function approve(address _spender, uint256 _value) external returns (bool) {\n        _approve(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function transfer(address _to, uint256 _value) external returns (bool) {\n        _transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 value\n    ) external returns (bool) {\n        // set infinite approval if allowance is max\n        // otherwise decrease allowance\n        if (\n            allowance[_from][msg.sender] != type(uint256).max &&\n            allowance[_from][msg.sender] != 0\n        ) {\n            allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(\n                value\n            );\n        }\n\n        _transfer(_from, _to, value);\n        return true;\n    }\n\n    function _transfer(address _from, address _to, uint256 value) private {\n        balanceOf[_from] = balanceOf[_from].sub(value);\n        balanceOf[_to] = balanceOf[_to].add(value);\n        emit Transfer(_from, _to, value);\n    }\n\n    function _approve(\n        address _owner,\n        address _spender,\n        uint256 _value\n    ) private {\n        require(_spender != address(0), \"Spender cannot be 0 address\");\n        require(_owner != address(0), \"Owner cannot be 0 address\");\n\n        allowance[_owner][_spender] = _value;\n        emit Approval(_owner, _spender, _value);\n    }\n\n    function _mint(address _to, uint256 _value) internal {\n        totalSupply = totalSupply.add(_value);\n        balanceOf[_to] = balanceOf[_to].add(_value);\n        emit Transfer(address(0), _to, _value);\n    }\n\n    function _burn(address _from, uint256 _value) internal {\n        balanceOf[_from] = balanceOf[_from].sub(_value);\n        totalSupply = totalSupply.sub(_value);\n        emit Transfer(_from, address(0), _value);\n    }\n}\n"
    },
    "contracts/factory/SwapPairTokensFactory.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\nimport \"../core/SwapPairTokens.sol\";\n\ncontract SwapPairTokensFactory {\n    address public feeTo;\n    address public feeToSetter;\n\n    mapping(address => mapping(address => address)) public getPair;\n    address[] public allPairs;\n\n    event PairCreated(\n        address indexed token0,\n        address indexed token1,\n        address pair,\n        uint256\n    );\n\n    constructor(address _feeToSetter) {\n        feeToSetter = _feeToSetter;\n    }\n\n    function allPairsLength() external view returns (uint256) {\n        return allPairs.length;\n    }\n\n    function createPair(\n        address tokenA,\n        address tokenB\n    ) external returns (address pair) {\n        require(\n            tokenA != tokenB,\n            \"SwapPairTokensFactory::createPair: IDENTICAL_ADDRESSES\"\n        );\n        (address token0, address token1) = tokenA < tokenB\n            ? (tokenA, tokenB)\n            : (tokenB, tokenA);\n        require(\n            tokenA != address(0),\n            \"SwapPairTokensFactory::createPair: ZERO_ADDRESS\"\n        );\n        require(\n            getPair[token0][token1] == address(0),\n            \"SwapPairTokensFactory::createPair: PAIR_EXISTS\"\n        ); // single check is sufficient\n        bytes memory bytecode = type(SwapPairTokens).creationCode;\n        bytes32 salt = keccak256(abi.encodePacked(token0, token1));\n        assembly {\n            pair := create2(0, add(bytecode, 32), mload(bytecode), salt)\n        }\n        SwapPairTokens(pair).initialize(token0, token1);\n\n        getPair[token0][token1] = pair;\n        getPair[token1][token0] = pair; // populate mapping in the reverse direction\n        allPairs.push(pair);\n        emit PairCreated(token0, token1, pair, allPairs.length);\n    }\n\n    function setFeeTo(address _feeTo) external {\n        require(\n            msg.sender == feeToSetter,\n            \"SwapPairTokensFactory::setFeeTo: FORBIDDEN\"\n        );\n        feeTo = _feeTo;\n    }\n\n    function setFeeToSetter(address _feeToSetter) external {\n        require(\n            msg.sender == feeToSetter,\n            \"SwapPairTokensFactory::setFeeToSetter: FORBIDDEN\"\n        );\n        feeToSetter = _feeToSetter;\n    }\n}\n"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\ninterface IERC20 {\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function totalSupply() external view returns (uint256);\n\n    function decimals() external view returns (uint256);\n\n    function balanceOf(address _owner) external view returns (uint256);\n\n    function allowance(\n        address _owner,\n        address _spender\n    ) external view returns (uint256);\n\n    function approve(address _spender, uint256 _value) external returns (bool);\n\n    function transfer(address _to, uint256 _value) external returns (bool);\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) external returns (bool);\n}\n"
    },
    "contracts/interfaces/ISwapFactory.sol": {
      "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.19;\n\ninterface ISwapFactory {\n    event PairCreated(\n        address indexed token0,\n        address indexed token1,\n        address pair,\n        uint256\n    );\n\n    function feeTo() external view returns (address);\n\n    function feeToSetter() external view returns (address);\n\n    function getPair(\n        address _tokenA,\n        address _tokenB\n    ) external view returns (address pair);\n\n    function allPairs(uint256) external view returns (address pair);\n\n    function allPairsLength() external view returns (uint256);\n\n    function createPair(\n        address _tokenA,\n        address _tokenB\n    ) external returns (address pair);\n\n    function setFeeTo(address) external;\n\n    function setFeeToSetter(address) external;\n}\n"
    },
    "contracts/libraries/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n// a library for performing various math operations\n\nlibrary Math {\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x < y ? x : y;\n    }\n\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n}\n"
    },
    "contracts/libraries/safeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/libraries/UQ112x112.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\n\n// range: [0, 2**112 - 1]\n// resolution: 1 / 2**112\n\nlibrary UQ112x112 {\n    uint224 constant Q112 = 2 ** 112;\n\n    // encode a uint112 as a UQ112x112\n    function encode(uint112 y) internal pure returns (uint224 z) {\n        z = uint224(y) * Q112; // never overflows\n    }\n\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\n    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {\n        z = x / uint224(y);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}